<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript——继承]]></title>
    <url>%2Fblog%2F2019%2F02%2F20%2Fcjse28l2n000evf6ps8nu8j3s%2F</url>
    <content type="text"><![CDATA[前言这篇文章将记录 JavaScript 中的几种继承方式（不含 es6），并分析其中的优缺点。另一方面也加深一下对原型链的理解。 原型链继承12345678910111213141516function Parent () &#123; this.name = &apos;xiaoming&apos;;&#125;Parent.prototype.getName = function () &#123; console.log(this.name);&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();console.log(child1.getName()) // xiaoming 简而言之，原型链继承就是就是直接将父类的一个实例赋给子类的原型。如代码中所示，这种方法是直接 new 了一个父类的实例，然后赋给子类的原型。这样也就相当于直接将父类原型中的方法属性以及挂在 this 上的各种方法属性全赋给了子类的原型，简单粗暴！最后在子类实例中寻找 getName 方法时，子类实例中没有，便会到原型链上去找。这种继承方式有两个缺点： 引用类型的属性被所有实例共享 在创建 Child 的实例时，不能向 Parent 传参 借用构造函数（经典继承）1234567891011121314151617function Parent () &#123; this.names = [&apos;one&apos;, &apos;two&apos;];&#125;function Child () &#123; Parent.call(this);&#125;var child1 = new Child();child1.names.push(&apos;three&apos;);console.log(child1.names); // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]var child2 = new Child();console.log(child2.names); // [&quot;one&quot;, &quot;two&quot;] 这种方式，避免了引用类型的属性被所有实例共享，并且可以在 Child 中向 Parent 传参。 1234567function Parent (name) &#123; this.name = name;&#125;function Child (name) &#123; Parent.call(this, name);&#125; 缺点：方法都在构造函数中定义，每次创建实例都会创建一遍方法。 组合继承组合继承结合了上述两种继承方法 123456789101112131415161718192021222324252627282930313233function Parent (name) &#123; this.name = name; this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();Child.prototype.constructor = Child;var child1 = new Child(&apos;kevin&apos;, &apos;18&apos;);child1.colors.push(&apos;black&apos;);console.log(child1.name); // kevinconsole.log(child1.age); // 18console.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var child2 = new Child(&apos;daisy&apos;, &apos;20&apos;);console.log(child2.name); // daisyconsole.log(child2.age); // 20console.log(child2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;] 寄生组合式继承组合继承最大的缺点是会调用两次父构造函数。一次是设置子类型实例的原型的时候：Child.prototype = new Parent();一次在创建子类型实例的时候：var child1 = new Child(&#39;kevin&#39;, &#39;18&#39;);为了解决重复调用的问题，在这里我们不使用 Child.prototype = new Parent()，而是间接的让 Child.prototype 访问到 Parent.prototype 1234567891011121314151617181920function Parent (name) &#123; this.name = name; this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;// 关键的三步var F = function () &#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F(); 其实这三行代码就是对 ES5 中 Object.create()的模拟 123var F = function () &#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F(); 也可以直接用 ES5 的 Object.create()Child.prototype = Object.create(Parent.prototype) 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。]]></content>
      <tags>
        <tag>JavaScript原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript运行机制：Event Loop]]></title>
    <url>%2Fblog%2F2019%2F02%2F01%2Fcjse28l2t000ovf6poqxz70bk%2F</url>
    <content type="text"><![CDATA[单线程的 JavaScriptJavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么 JavaScript 不能有多个线程呢？这样能提高效率啊。JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 任务队列单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 设备（输入输出设备）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时主线程完全可以不管 IO 设备，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 设备返回了结果，再回过头，把挂起的任务继续执行下去。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 具体来说，异步执行的运行机制如下。 所有同步任务都在主线程上执行，形成一个 执行栈 （execution context stack）。 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 主线程不断重复上面的第三步。 除了我们的主线程之外，任务队列分为 microtask 和 macrotask，通常我们会称之为微任务和宏任务。 microtask 这一名词在 js 中是个比较新的概念，我们通常是在学习 ES6 的 Promise 时才初次接触到。 执行优先级上，主线程任务 &gt; microtask &gt; macrotask。 典型的 macrotask 有 setTimeout 和 setInterval，以及只有 IE 支持的 setImmediate，还有 MessageChannel 等，ES6 的 Promise 则是属于 microtask macro-task(宏任务)：包括整体代码 script，setTimeout，setIntervalmicro-task(微任务)：Promise，process.nextTick ￼ 事件和回调函数“任务队列”是一个事件的队列（也可以理解成消息的队列），IO 设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。“任务队列”中的事件，除了 IO 设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。 Event Loop主线程从”任务队列”中读取事件，一次循环的执行称之为 tick，在这个循环里执行的代码被称作 task，而整个过程是不断重复的，所以整个的这种运行机制又称为 Event Loop（事件循环）。 ￼ 上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部 API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。]]></content>
      <tags>
        <tag>JavaScript原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript——闭包]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2Fcjse28l2o000gvf6pxzz42xwl%2F</url>
    <content type="text"><![CDATA[什么是闭包MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成：闭包 = 函数 + 函数能够访问的自由变量 ECMAScript 中，闭包指的是：1、从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。2、从实践角度：以下函数才算是闭包：（1）即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）（2）在代码中引用了自由变量 举例分析在《JavaScript 权威指南》中关于闭包有这样一个例子 12345678910var scope = &quot;global scope&quot;;function checkscope()&#123; var scope = &quot;local scope&quot;; function f()&#123; return scope; &#125; return f;&#125;var foo = checkscope();foo(); 根据之前所学习的，不难分析出这段代码的执行过程 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this 等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this 等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 可以发现，当 f 函数执行的时候，checkscope 函数上下文已经从执行上下文栈弹出了，那怎么怎么还会读取到 checkscope 作用域下的 scope 值呢？我们分析一下 f 的作用域链可以发现 123fContext = &#123; Scope: [AO, checkscopeContext.AO, globalContext.VO],&#125; 就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。 一道面试题1234567891011var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function () &#123; console.log(i); &#125;;&#125;data[0]();data[1]();data[2](); 答案是都是 3。当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行 data[0] 函数的时候，data[0] 函数的执行上下文的活动对象中没有 i，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。data[1] 和 data[2] 是一样的道理。 那么如何得到我们想要的结果呢？ 第一种方法：可以将 var 改成 ES6 的 let 第二种方法：使用闭包 12345678910111213var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function (i) &#123; return function()&#123; console.log(i); &#125; &#125;)(i);&#125;data[0]();data[1]();data[2](); 当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变 123data[0]Context = &#123; Scope: [AO, 匿名函数Context.AO globalContext.VO]&#125; 匿名函数执行上下文的 AO 为： 123456789匿名函数Context = &#123; AO: &#123; arguments: &#123; 0: 0, length: 1 &#125;, i: 0 &#125;&#125; data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为 3)，所以打印的结果就是 0。]]></content>
      <tags>
        <tag>JavaScript原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript——作用域链]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2Fcjse28l290005vf6pz4b1h45x%2F</url>
    <content type="text"><![CDATA[什么是作用域链JavaScript 在查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。我们从函数创建和函数激活两个时期来看作用域链的变化 函数创建函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！ 12345function foo() &#123; function bar() &#123; ... &#125;&#125; 上述两个函数的作用域链分别是 12345678foo.[[scope]] = [ globalContext.VO];bar.[[scope]] = [ fooContext.AO, globalContext.VO]; 函数激活当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。这时候执行上下文的作用域链，我们命名为 Scope。以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程： 123456var scope = &quot;global scope&quot;;function checkscope()&#123; var scope2 = &apos;local scope&apos;; return scope2;&#125;checkscope(); checkscope 函数被创建，保存作用域链到 内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO]; 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1234ECStack = [ checkscopeContext, globalContext]; checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链 123checkscopeContext = &#123; Scope: checkscope.[[scope]],&#125; 第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: undefined &#125;， Scope: checkscope.[[scope]]&#125; 第三步：将活动对象压入 checkscope 作用域链顶端 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: undefined &#125;, Scope: [AO, [[Scope]]]&#125; 准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: &apos;local scope&apos; &#125;, Scope: [AO, [[Scope]]]&#125; 查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出。 123ECStack = [ globalContext];]]></content>
      <tags>
        <tag>JavaScript原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript——变量对象]]></title>
    <url>%2Fblog%2F2019%2F01%2F24%2Fcjse28l2i000bvf6pw22nd4d3%2F</url>
    <content type="text"><![CDATA[前言对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO)：变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。 作用域链(Scope chain) this 全局上下文全局上下文中的变量对象就是全局对象。全局对象是个啥？在 w3cschool 关于全局对象的描述如下 全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。全局对象不是任何对象的属性，所以它没有名称。 在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。但通常不必用这种方式引用全局对象，因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。例如，当 JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。 全局对象只是一个对象，而不是类。既没有构造函数，也无法实例化一个新的全局对象。简单的说，全局对象就是 可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。 由 Object 构造函数实例化的一个对象。 作为全局变量的宿主。 预定义了一大堆函数和属性。 函数上下文活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。 执行过程执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做： 进入执行上下文 代码执行 进入执行上下文当进入执行上下文时，这时候还没有执行代码，变量对象会包括： 函数的所有形参 (如果是函数上下文)：由名称和对应值组成的一个变量对象的属性被创建；没有实参，属性值设为 undefined； 函数声明：由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建；如果变量对象已经存在相同名称的属性，则完全替换这个属性； 变量声明：由名称和对应值（undefined）组成一个变量对象的属性被创建；如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性；（在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性） 12345678910function foo(a) &#123; var b = 2; function c() &#123;&#125; var d = function() &#123;&#125;; b = 3;&#125;foo(1); 进出执行上下文，这时候的 AO 为： 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, //形参 b: undefined, //变量声明 c: reference to function c()&#123;&#125;, //函数声明 d: undefined //函数变量声明&#125; 代码执行在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值还是上面的例子，当代码执行完后，这时候的 AO 是： 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: 3, c: reference to function c()&#123;&#125;, d: reference to FunctionExpression &quot;d&quot;&#125; 结语到这里变量对象的创建过程就介绍完了，总结我们上述所说： 全局上下文的变量对象初始化是全局对象 函数上下文的变量对象初始化只包括 Arguments 对象 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值 在代码执行阶段，会再次修改变量对象的属性值]]></content>
      <tags>
        <tag>JavaScript原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript——执行上下文栈]]></title>
    <url>%2Fblog%2F2019%2F01%2F22%2Fcjse28l2m000cvf6pd58r3vyw%2F</url>
    <content type="text"><![CDATA[顺序执行如果要问到 JavaScript 代码执行顺序的话，想必写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行看下面两个例子 1234567891011var foo = function () &#123; console.log(&apos;foo1&apos;);&#125;foo(); // foo1var foo = function () &#123; console.log(&apos;foo2&apos;);&#125;foo(); // foo2 顺序执行没毛病～然而看下面这个： 1234567891011function foo() &#123; console.log(&apos;foo1&apos;);&#125;foo(); // foo2function foo() &#123; console.log(&apos;foo2&apos;);&#125;foo(); // foo2 输出结果是两个 foo2这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。第二个例子中，函数的声明被提升了，输出 foo2 的函数覆盖了前一个函数，所以两次调用的输出都是 foo2。 可执行代码JavaScript 的可执行代码有三种：全局代码、函数代码、eval 代码。当遇到可执行代码时，就会进行准备工作，这里的“准备工作”，用个更专业一点的说法，就叫做”执行上下文(execution context)”。 执行上下文栈JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。我们可以通过一个数组来模拟：ECStack = [];试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext： 123ECStack = [ globalContext]; 接下来遇到了这样一段代码： 12345678910111213function fun3() &#123; console.log(&apos;fun3&apos;)&#125;function fun2() &#123; fun3();&#125;function fun1() &#123; fun2();&#125;fun1(); 那么执行上下文栈的变化如何呢？ 12345678910111213141516171819// fun1()ECStack.push(&lt;fun1&gt; functionContext);// fun1中调用了fun2，创建fun2的执行上下文ECStack.push(&lt;fun2&gt; functionContext);// fun2还调用了fun3，创建fun3的执行上下文ECStack.push(&lt;fun3&gt; functionContext);// fun3执行完毕ECStack.pop();// fun2执行完毕ECStack.pop();// fun1执行完毕ECStack.pop();// javascript接着执行下面的代码，但是ECStack底层永远有一个globalContext]]></content>
      <tags>
        <tag>JavaScript原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript——作用域]]></title>
    <url>%2Fblog%2F2019%2F01%2F22%2Fcjse28l2b0007vf6p9xb00dox%2F</url>
    <content type="text"><![CDATA[什么是作用域作用域是指程序源代码中定义变量的区域。作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 静态作用域和动态作用域 因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。（这里要划重点） 123456789101112var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar(); 假设 JavaScript 采用静态作用域，让我们分析下执行过程：执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。 假设 JavaScript 采用动态作用域，让我们分析下执行过程：执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。 JavaScript 采用的是静态作用域，所以这个例子的结果是 1。]]></content>
      <tags>
        <tag>JavaScript原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript——原型与原型链]]></title>
    <url>%2Fblog%2F2019%2F01%2F21%2Fcjse28l2d0008vf6p5n7ydvs7%2F</url>
    <content type="text"><![CDATA[构造函数在 JavaScript 中构造函数和 Java 中的函数一样也可以创建对象实例。 例如下面的代码： 1234function Person() &#123;&#125;var person = new Person();person.name = &apos;myname&apos;; Person 是一个构造函数，我们使用 new 创建了一个实例对象 person。 prototype每一函数都有一个 prototype 属性，这个 prototype 属性指向一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是 person 的原型。 什么是原型：每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。那么 person 的原型该如何表示呢？ proto这是每一个 JavaScript 对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。在浏览器控制台中输入如下的代码可以证明这一点： 12345function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 由此可以知道，构造函数和实例可以指向原型，那么原型是否有属性指向构造函数和实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。在浏览器中控制台输入如下代码可以证明 1234function Person() &#123;&#125;console.log(Person === Person.prototype.constructor); // true 实例和原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。形象一点描述，就是儿子的属性里找不到，就到爸爸的属性里找，爸爸的属性里找不到就到爸爸的爸爸的属性里去找……以此类推。知道找到原型的原型，那原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是： 123var obj = new Object();obj.name = &apos;myname&apos;console.log(obj.name) // myname 其实原型对象就是通过 Object 构造函数生成的。 原型链那 Object.prototype 的原型呢？答案是：null，我们可以尝试： 1console.log(Object.prototype.__proto__ === null) // true null 表示没有对象，即该处不应该有值。所以 Object.prototype.__proto__的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。所以查找属性的时候查到 Object.prototype 就可以停止查找了。盗用一下伢羽大大博客上的图片，关系图如下：图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。]]></content>
      <tags>
        <tag>JavaScript原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现基于JWT的Token登录验证功能]]></title>
    <url>%2Fblog%2F2019%2F01%2F20%2Fcjse28l2u000qvf6pdo7fs7kv%2F</url>
    <content type="text"><![CDATA[前言放假之前做了几个小项目+课设，都用到了 token 实现登录验证和权限判断，然鹅当时和同组的小伙伴也都是第一次接触到了 token，于是乎都是一脸懵逼（xjbx）的写完了登录验证的前后端逻辑（我写前端，同组的小伙伴写后端）。今天有空仔细学习了一下 SpringBoot 实现 token 认证以及和前端的交互，踩了不少坑，在这里记录一下（现在已经 12:30 了…好困=·=） 后端实现 首先需要导入 jwt 的包，相关的 pom.xml 文件如下： 12345&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt;&lt;/dependency&gt; 然后开始编写 TokenUtil 类，首先定义 token 的过期时间和私钥 12private static final long EXPIRE_TIME = 15 * 60 * 1000;private static final String TOKEN_SECRET = &quot;thefirsttoken123&quot;; 实现签名方法：这里不应该使用密码进行加密，不安全，但是是自己的小 demo 就这样写了。 12345678910111213141516171819202122232425262728/** * 生成签名，15分钟过期 * @param **username*** @param **password*** @return */public static String sign(String username, String password) &#123; try &#123; // 设置过期时间 Date date = new Date(System.currentTimeMillis() + EXPIRE_TIME); // 私钥和加密算法 Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET); // 设置头部信息 Map&lt;String, Object&gt; header = new HashMap&lt;&gt;(2); header.put(&quot;Type&quot;, &quot;Jwt&quot;); header.put(&quot;alg&quot;, &quot;HS256&quot;); // 返回token字符串 return JWT.create() .withHeader(header) .withClaim(&quot;loginName&quot;, username) .withClaim(&quot;pwd&quot;, password) .withExpiresAt(date) .sign(algorithm); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125;&#125; 实现 token 的检验方法： 123456789101112131415/** * 检验token是否正确 * @param **token*** @return */public static boolean verify(String token)&#123; try &#123; Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET); JWTVerifier verifier = JWT.require(algorithm).build(); DecodedJWT jwt = verifier.verify(token); return true; &#125; catch (Exception e)&#123; return false; &#125;&#125; 至此，工具类就编写完成啦！ 登录的 controller 层方法这里获取到前端发送过来的请求体，取出其中的用户名和密码，和数据库比对如果无误的话，签发 token，并返回给前端。（API 响应结果还没有封装，看着有点乱，嘿嘿） 123456789101112131415161718@PostMapping(value = &quot;/login&quot;)public Map&lt;String, Object&gt; login(@RequestBody SysUser sysUser)&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); String username = sysUser.getUsername(); String password = sysUser.getPassword(); if (sysUserService.login(username, password))&#123; String token = TokenUtil.sign(username,password); if (token != null)&#123; map.put(&quot;code&quot;, &quot;10000&quot;); map.put(&quot;message&quot;,&quot;认证成功&quot;); map.put(&quot;token&quot;, token); return map; &#125; &#125; map.put(&quot;code&quot;, &quot;00000&quot;); map.put(&quot;message&quot;,&quot;认证失败&quot;); return map;&#125; 现在服务端给客户端签发 token 的功能已经差不多实现了。那么客户端如何将 token 应用到以后的请求中，服务端又如何识别 token 呢？ 实现服务端自定义拦截器 1234567891011121314151617181920212223242526/** * 自定义token拦截器 */@Componentpublic class TokenInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (request.getMethod().equals(&quot;OPTIONS&quot;))&#123; response.setStatus(HttpServletResponse.SC_OK); return true; &#125; response.setCharacterEncoding(&quot;utf-8&quot;); String token = request.getHeader(&quot;admin-token&quot;); if (token != null)&#123; boolean result = TokenUtil.verify(token); if(result)&#123; System.out.println(&quot;通过拦截器&quot;); return true; &#125; &#125; System.out.println(&quot;认证失败&quot;); response.getWriter().write(&quot;50000&quot;); return false; &#125;&#125; TokenInterceptor 实现了 HandlerInterceptor 接口，重写了 preHandle 方法，该方法是在每个请求之前触发执行，从 request 的头里面取出 token，这里我们统一了存放 token 的键为 admin-token，验证通过，放行，验证不通过，返回认证失败信息。这里有一个坑，由于每次前端发送请求，都会先发一次预请求，也就是 RequestMethod 为OPTIONS不是我们常见的 get、post 等（关于 OPTIONS 的解释，可以谷歌一下）。所有在这里我们需要做一次判断，如果请求方法为 OPTIONS，那么就直接 return 通过。 配置拦截器对登录界面的请求不拦截 12345678910111213141516@Configurationpublic class InterceptorConfig extends WebMvcConfigurerAdapter &#123; private TokenInterceptor tokenInterceptor; public InterceptorConfig(TokenInterceptor tokenInterceptor) &#123; this.tokenInterceptor = tokenInterceptor; &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; List&lt;String&gt; excludePath = new ArrayList&lt;&gt;(); String sysUserLogin = &quot;/api/sysUser/login&quot;; excludePath.add(sysUserLogin); registry.addInterceptor(tokenInterceptor).excludePathPatterns(excludePath); &#125;&#125; 服务端解析 token现在为了之后根据 token 去做相关的查询，我们需要对 token 进行解密，取出之前加密的 loginName。然后就可以愉快的增删查改啦～ 1234567891011121314/** * 从token中获取username信息 * @param **token*** @return */public static String getUserName(String token)&#123; try &#123; DecodedJWT jwt = JWT.decode(token); return jwt.getClaim(&quot;loginName&quot;).asString(); &#125; catch (JWTDecodeException e)&#123; e.printStackTrace(); return null; &#125;&#125; 前端实现前端使用 vue+axios，主要是实现对 axios 的再封装。相关代码如下大致逻辑就是，如果 vuex 中已经存在了 token，那么就把它放到请求头中发往服务端。 12345678910111213141516171819// 创建axios实例const service = axios.create(&#123; baseURL: process.env.BASE_API // api 的 base_url&#125;)// request拦截器service.interceptors.request.use( config =&gt; &#123; if (store.getters.token) &#123; config.headers[&apos;admin-token&apos;] = getToken() // 让每个请求携带自定义token &#125; return config &#125;, error =&gt; &#123; // 出错 console.log(error) Promise.reject(error) &#125;) 结语嗯…..现在已经 1 点多了，不由得又想起那副对联。 昨日今日明日日日码不停蹄，去年今年明年年年都是单身。横批：这就是命 晚安～]]></content>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统——虚拟存储器]]></title>
    <url>%2Fblog%2F2019%2F01%2F09%2Fcjse28l2z0011vf6pdphmmxxk%2F</url>
    <content type="text"><![CDATA[虚拟存储器的思想把内存中暂时不能运行或者暂时不用的程序、数据调动外存上。或者说把程序的一部分放入内存、一部分放在外存。程序运行时，如果所需要访问的页（段）已调入内存，便可继续执行下去；但如果程序所要访问的页（段）尚未调入内存（即缺页或缺段），则程序利用 OS 所提供的请求调页（段）功能，将它们调入内存，以使进程继续执行；如果此时，内存已满，则需利用页（段）置换功能。 置换分类：页面对换－－请求分页存储管理(基本分页+页面对换)分段对换－－请求分段存储管理(基本分段+分段对换) 请求分页系统基本思想 在基本分页基础上，增加调页功能和页面置换功能；每次调入和换出的基本单位都是长度固定的页面 硬件支持要想在基本分页的基础上实现虚拟存储管理，需要 页表机制 缺页中断机构请求分页系统中、每当发现要访问的页面不在内存、便产生中断通知 os 调入缺页。要经过 保护 CPU 现场、分析中断原因、执行缺页中断程序、执行完毕恢复现场 等步骤。 与一般中断相比，缺页中断有着明显的不同，主要表现在以下两个方面：(1)通常，CPU 是在一条指令执行完后，才检查是否有中断请求到达。若有，便去响应；否则，继续执行下一条指令。然而，缺页中断则是在指令执行期间，发现所要访问的指令或数据不在内存时所产生和处理的。(2)一条指令在执行期间，可能产生多次缺页中断。 页面置换算法最佳置换算法 思想：被置换的页面是以后永远不使用或以后长时间不使用的 举例：系统为某个进程（有 8 个页面）只分配了 3 个物理块、进程有如下的页面号引用 7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1 求该进程在最佳置换算法下执行完毕缺页多少次? 中断多少次？缺页率为多少？页面置换多少次？ 先进先出置换算法(FIFO first in first out) 思想：淘汰最先进入内存的页面、即选择在内存中驻留时间最久的页面给予淘汰。 最近最久未使用的置换算法(LRU lease recently used) 思想：选择和现在相比最长时间没有使用的页面进行置换。 硬件：寄存器：记录某进程在内存中各页的使用情况栈：用来保存当前使用的各个页面的页面号 CLOCK 置换算法 LRU 算法是较好的一种算法，但由于它要求有较多的硬件支持，故在实际应用中，大多采用 LRU 的近似算法。Clock 算法就是用得较多的一种 LRU 近似算法。 思想：为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位被置为 1.置换算法选择一位淘汰时，只需检查页的访问位。如果是 0，就选择该页换出；若为 1，则重新将它置 0，暂不换出，而给该页第二次驻留内存的机会，在按照 FIFO 算法检查下一个页面。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统——存储器管理]]></title>
    <url>%2Fblog%2F2019%2F01%2F09%2Fcjse28l2y000zvf6ppi7uceu8%2F</url>
    <content type="text"><![CDATA[存储器的层次结构多级存储器结构 程序的装入和链接在多道程序环境下，程序要运行必须为之创建进程，而创建进程的第一件事，就是要将程序和数据装入内存。如何将一个用户源程序变为一个可在内存中执行的程序，通常要经过以下几步 :（1）编译：由编译程序（Compiler）将用户源代码编译成若干个目标模 块（Object Module）；（2）链接：由链接程序（Linker）将编译后形成的目标模块以及它们所需要的库函数，链接在一起，形 成一个装入模块（Load Module）；（3）装入：由装入程序（Loader）将装入模块装入内存。 程序的链接 静态链接：在装入之前目标模块+库函数链接好,以后不在拆开 动态链接装入时动态链接：将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的方式。即在装入一个目标模块时，若发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块。便于修改和更新便于实现对目标模块的共享运行时动态链接：运行过程中，需要则链接拥有装入时动态链接的优点加快程序的装入过程，节省内存空间 程序的装入 方式：绝对装入 、可重定位装入 、动态运行时装入 需要注意的问题：（1）装入是从外存——&gt;内存；链接是从目标块——&gt;内存的进程（2）程序作业中相对地址或逻辑地址——&gt;进程执行需要内存绝对地址或物理地址。因而在装入时，存在着地址转换，称为重定位。 绝对装入：只能将目标模块装入指定的内存位置 可重定位的装入： 装入时将逻辑地址转换为物理地址(重定位)，逻辑地址从 0 开始 动态运行时装入：模块装入内存后没有立即重定位，仍然是相对地址；只有当 cpu 执行到具有相对地址的代码时才去重定位——&gt;动态重定位 内存的分配单一连续分配： 最简单的一种单用户、单任务的分配方式 内存分成系统区和用户区两部分 固定分区分配在单一连续分配的基础上，将用户区划分成若干个固定大小的区，每个区可以放一个作业进程，多个进程并发。系统一启动后就已经分好了分区 分区大小划分方法：（1）分区大小相等：缺乏灵活性；内存空间浪费（2）分区大小不等： 动态分区 根据作业或进程的需要，动态的分配内存，一开始不分区 数据结构：空闲分区表或者空闲分区链空闲分区表：以表结构形式记录每个空闲分区的情况。空闲分区链：以链表形式记录每个空闲分区的情况。 首次适应算法从空闲分区表或分区链（按照地址递增次序排列）上开始查找，找到第一个满足要求的分区为止，分配内存，余下的部分然仍留在空闲分区表中。 循环首次适应算法在为进程分配内存空间时，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个分区开始查找，直至找到一个能满足要求的空闲分区，从中找出一块与请求大小相等的内存空间分配给作业。为实现该算法，应设置一起始查寻指针，用于指示下一个起始查寻的空闲分区，并采用循环查找方法，即如果最后一个（链尾）空闲分区的大小仍不能满足，则应返回到第一个空闲分区，比较其大小是否满足。找到后，应调整起始查寻指针。 最佳适应算法将分配表按照分区容量按照从小到大排列，查找时只需要从表首按顺序查找最合适的。每次为作业分 配内存时，总是找一个既能满足要求、又是最小的空闲分区分配给作业。“最佳或最合适的”。 最坏适应算法所有的空闲分区按从大到小形成空闲分区链，每次分配总是挑选出分配（链）中最大的分区进行分配。优点：使剩下的空闲区不至于太小，产生的碎片几率小；有利于中小作业； 快速适应算法将空闲分区根据其容量大小进行分类，对每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，因此，系统中存在多个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。 可重定位分区分配 主存不存的存储管理技术 移动技术（主存紧凑） 对换技术 基本分页存储管理分页的思想 把逻辑地址空间（程序）分成若干个大小相等的片－－页面或页、加以编号 0 页、1 页、2 页……. 把内存也分成和页面大小相等的若干个物理存储块－－物理块加以编号 0 块、1 块、2 块…… 为进程分配内存时，将进程的~若干~个页装入多个~不相邻~的块中 由于进程的最后一页经常装不满一页，因而形成不可以利用的碎片，称为“页内碎片” 页面的大小 页面若太小:（1）虽然可使内存碎片减小，提高内存利用率（2）会使每个进程占用较多的页面，从而导致进程的页表过长，占用大量的内存（3）还会降低页面换进和换出的效率。 若页面太大:（1）减少页表的长度，提高页面换进换出的速度（2）增加页内碎片 因此页面的大小应选择合适，大小应是 2 的幂，通常为 512B-8KB。 基本分页存储管理的缺点：页表是放在内存中的，因此 Cpu 存取一个数据，需要访问内存 2 次。第一次，访问内存中的页表，找出逻辑地址对应的物理地址；第二次访问内存物理地址处的数据.因此，降低了上计算机的处理速度。 为了解决这一问题，引入快表快表是个具有并行查询能力的特殊高速缓冲寄存器（联想寄存器）快表内只存放当前访问的页表项很快、远远大于内存的速度、提高了地址变换的速度 基本分段存储管理分段的目的 推动存储管理从 固定分区－&gt;可变分区-&gt;分页存储管理的主要动力是 ：提高内存的利用率 引入分段管理的目的：满足程序员编写程序的要求：方便编程、信息共享、信息保护、动态增长、动态链接 分页与分段的主要区别 段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。 页的大小固定不变，由系统决定。段的大小是不固定的，它由其完成的功能决定。 段是向用户提供的是二维地址空间，页式向用户提供的是一维地址空间，其页号和页内偏移是机器硬件的功能。 由于段是信息的逻辑单位，因此便于存贮保护和信息的共享，页的保护和共享受到限制。 段页式存储管理引入段页式存储管理的原因页式管理可以提高内存利用率、段式管理可以满足用户需要，二者结合可以充分利用页式和段式的优点 基本思想先将用户程序分成若干个段、再把每个段中分成若干个页面，同时内存也分成与页面相同大小的块]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统——处理机调度与死锁]]></title>
    <url>%2Fblog%2F2019%2F01%2F09%2Fcjse28l2x000xvf6pmoqt14x9%2F</url>
    <content type="text"><![CDATA[处理机调度的层次 低级调度（内存——&gt;处理器） 又称为进程或短程调度，调度对象是进程（内核级线程），进程调度是最基本的一种调度。主要功能：（1）保存处理机的现场信息（2）按某种算法选取进程（3）把处理器分配给进程 进程调度方式（1）非抢占式系统开销小，适用于大多数的批处理 OS 环境难以满足紧急任务的要求-立即执行（2）抢占式防止一个长进程长时间占用处理机，为大多数进程提供更公平的服务（优点）系统开销大（缺点） 中级调度（内存——&gt;外存）主要目的：为了提高内存利用率和系统吞吐量@ 高级调度（外存 内存 ）@ 低级调度（内存 处理器）@ 中级调度（内存 外存 ） 高级调度（外存——&gt;内存） 调度算法作业周转与平均周转时间 如果作业 i 提交给系统的时刻是 ts，完成时刻是 tf，该作业的周转时间 ti 为：ti = tf - ts 平均作业周转时间 T = (Σti) / n 先来先服务调度算法 有利于CPU繁忙型的作业，不利于I/O繁忙性的作业 不利于短作业，而优于长作业 最短作业调度算法该算法对长作业不利该算法完全未考虑作业的紧迫程度 高响应比调度算法响应比 =作业周转时间/作业处理时间=(作业等待时间+作业处理时间)/作业处理时间=1+作业等待时间/作业处理时间 高优先权调度算法 优先权调度算法(FPF)的类型非抢占式优先权算法抢占式优先权算法 优先权的类型静态优先权动态优先权 时间片轮转调度算法 多级反馈调度算法 产生死锁的原因和必要条件 产生死锁的原因可归结为以下两点：1、竞争资源引起进程死锁：当系统中供多个进程所共享的资源，不足以同时满足他们的需要时，引起他们对资源的竞争而引起死锁。2、进程推进顺序不当引起死锁：进程在运行过程中，请求和释放资源的顺序不当，导致了进程死锁。 操作系统中的死锁指：如果在一个进程集合中的每个进程都在等待只能由该集合中的其他一个进程才能引发的事件，则称一组进程或系统此时发生死锁。 系统形成死锁的四个必要条件互斥条件：进程互斥使用资源部分分配条件：申请新资源时不释放已占有资源不剥夺条件：一个进程不能抢夺其他进程占有的资源环路条件：存在一组进程循环等待资源的,即进程集合{P0,P1,P2,…Pn}中的 P0 正在等待 P1 占用的资源， P1 正在等待 P2 占用的资源，…… Pn 正在等待 P0 占用的资源 产生死锁必须同时满足上述四个条件，一个不满足死锁便不会发生 处理死锁的基本方法 预防死锁 避免死锁 检测死锁通过系统设置的检测机构，及时检测出死锁的发生，精 确地确定于死锁有关的进程和资源；然后采取适当措施，从系统中将已发生的死锁清除掉。 解除死锁与检测死锁配套的措施。当检测到系统中已发生死锁时， 须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。 银行家算法 系统中的所有进程进入进程集合, 在安全状态下系统收到进程的资源请求后,先把资源试探性分配给它。 系统用剩下的可用资源和进程集合中其他进程还要的资源数作比较，在进程集合中找到剩余资源能满足最大需求量的进程,从而,保证这个进程运行完毕并归还全部资源。 把这个进程从集合中去掉, 系统的剩余资源更多了,反复执行上述步骤。 最后,检查进程集合,若为空表明本次申请可行,系统处于安全状态,可实施本次分配;否则,有进程执行不完，系统处于不安全状态,本次资源分配暂不实施,让申请进程等待。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统——进程管理]]></title>
    <url>%2Fblog%2F2019%2F01%2F09%2Fcjse28l3r001xvf6pzlb0gbl8%2F</url>
    <content type="text"><![CDATA[进程的基本概念程序的顺序执行及其特征 程序：一个在时间上按严格次序、顺序执行的操作序列 程序的顺序执行：一个具有独立功能的程序独占处理剂，直到得到最终结果特征：顺序性：一个程序的各个部分的执行，严格地按照某种先后次序执行；封闭性：程序在封闭的环境下运行，即程序运行时独占全部系统资源；可再现性：只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都将获得相同的结果。 前趋图（DAG）前趋图是有向无循环图 程序的并发执行及其特征 不可再现性：由于程序的并发执行，打破了由另一程序独占系统 资源的封闭性，因而破坏了可再现性。 间断性：程序并发执行时，由于它们共享资源或程序之间相互合作完成一项共同任务，因而使程序之间相互制约。 通信性：对于相互合作的程序，为了更有效地协调运行，相互之间进 行通信。 独立性：并发程序在运行过程中，既然是作为一个独立的运行实体，它也必然具有作为一个单位去获得资源的独立性。 程序和进程的区别：进程就是一个活跃着的程序（动态的）,即:已经被放入了系统调度队列当中了,占有一定的系统资源的程序. 进程的特征与状态 结构性：程序块、数据块、进程控制块（PCB）进程实体=程序段+相关的数据段+PCB进程创建和撤销都是创建和撤销的 PCB 动态性：进程是程序在数据集合上的一次执行过程，有生命周期：由创建而产生、由调度而执行、由事件而等待、由撤销而消亡。 并发性：多个进程实体同存于内存中，能在一段时间内同时运行。是进程的重 要特征。 独立性：进程是系统中资源分配、保护和调度的基本单位 异步性：进程按各自独立的，不可预知的速度向前推进 进程的状态转换三态转换图 挂起：进程被交换到外存，状态变为挂起状态进程进入挂起状态是由于操作系统、父进程或进程本身阻止它的运行。结束进程挂起状态的命令只能通过操作系统或父进程发出。 进程控制块（PCB） 系统为了管理进程设置的一个专门的数据结构，存放了用于描述该进程情况和控制进程运行所需的全部信息。 系统利用 PCB 来控制和管理进程，所以 PCB 是系统感知进程存在的唯一标志 进程与 PCB 是一一对应的 作用：使一个在多道程序环境下不能独立运行的程序（含数据），成为一个独立运行的基本单位。 进程同步基本概念 进程互斥：指在多道程序环境下，每次只允许一个进程对临界资源进行访问。 进程同步：指多个相关进程在执行次序上的协调 临界资源:一次仅供一个进程使用的资源。 在进程中涉及到临界资源的程序段叫临界区 多个进程的临界区称为相关临界区 进程的同步机制 ── 信号量及 P.V 操作（解决进程同步,互斥问题） 进程间的两种制约关系 直接作用(相互合作）：进程间的相互联系是有意识的安排的，直接作用只发生在相交进程间进程的同步 间接作用（资源共享）：进程间要通过某种中介发生联系，是无意识安排的，可发生在相交进程之间，也可发生在无关进程之间进程的互斥由于各进程要求共享资源，而有些资源需要互斥使用，因此各进程间竞争使用这些资源，进程的这种关系为进程的互斥。 同步是一种更为复杂的互斥，而互斥是一种特殊的同步 生产者-消费者问题 P、V 信号量 P 和 V 是来源于两个荷兰语词汇，P() —prolaag （荷兰语，尝试减少的意思），V() —verhoog（荷兰语，增加的意思） 信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；（阻塞）up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。（唤醒） 如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。 12345678910111213141516171819202122232425262728#define N 100typedef int semaphore;semaphore mutex = 1;semaphore empty = N;semaphore full = 0;void producer() &#123; while(TRUE)&#123; int item = produce_item(); // 生产一个产品 // down(&amp;empty) 和 down(&amp;mutex) 不能交换位置，否则造成死锁 down(&amp;empty); // 记录空缓冲区的数量，这里减少一个产品空间 down(&amp;mutex); // 互斥锁 insert_item(item); up(&amp;mutex); // 互斥锁 up(&amp;full); // 记录满缓冲区的数量，这里增加一个产品 &#125;&#125;void consumer() &#123; while(TRUE)&#123; down(&amp;full); // 记录满缓冲区的数量，减少一个产品 down(&amp;mutex); // 互斥锁 int item = remove_item(); up(&amp;mutex); // 互斥锁 up(&amp;empty); // 记录空缓冲区的数量，这里增加一个产品空间 consume_item(item); &#125;&#125; 注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，也就无法执行 up(empty) 操作，empty 永远都为 0，那么生产者和消费者就会一直等待下去，造成死锁。 哲学家进餐问题如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。有多种办法可以解决这个问题1、只有哲学家两只手的筷子都可以用时，才允许他吃饭2、奇数号先取左手边的叉子，偶数号先取右手边的筷子； 管程机制 P.V 操作的优缺点：简单，而且表达能力强（用 P.V 操作可解决任何同步和互斥问题），但 P, V 操作代码均由用户编写，计算机系统无法有效地控制和管理这些 P，V 操作。分散在各进程中的临界段没有集中加以管理不够安全；P.V 操作使用不当会出现死锁；且这种错误只有在特定顺序下才出现；遇到复杂同步和互斥问题时实现复杂。总之，信号量(P,V)不是最安全的进程通讯手段管程的基本原理把分散在各进程中的临界区集中起来管理，并把共享资源用数据结构抽象地表示出来,代表共享资源的数据结构及并发进程在其上执行的一组过程就构成管程。 管程的属性模块化：管程是一个基本程序单位抽象数据类型：管程中不仅有数据，而且有对数据的操作信息掩蔽:管程的数据结构只能供过程调用，过程内的过程被管程外的进程调用，数据结构和过程对外不可见 通常系统为每个共享资源设置一个管程 进程通信通信机制每 个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程 1 把数据从用户空间拷到内核缓冲区，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess ommunication） 高级通信机制分类 共享存储器系统 管道通信管道(pipeline)是连接读写进程的一个特殊文件，允许进程按先进先出方式传送数据,也能使进程同步执行操作。发送进程以字符流形式把大量数据送入管道，接收进程从管道中接收数据，所以叫管道通信。管道的实质是一个共享文件，基本上可借助于文件系统的机制实现，包括（管道）文件的创建、打开、关闭和读写。 消息传递通信系统 线程及其实现进程的“独立分配资源”和“被调度分派执行”的功能分离 独立分配资源：由进程完成，作为系统资源分配和保护的独立单位，无须频繁的切换 被调度分派执行：交给线程的实体来完成，线程作为系统系统调度和分派的基本单位，会被频繁地调度和切换。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统——引论]]></title>
    <url>%2Fblog%2F2019%2F01%2F09%2Fcjse28l3p001vvf6pkvzsrz45%2F</url>
    <content type="text"><![CDATA[操作系统的目标和作用操作系统的目标 方便性：编写代码方便用户，方便计算机系统的使用 有效性：合理的组织计算机的工作流程，改善资源的利用率、提高系统吞吐量 可扩充性：操作系统采用层次化结构，以便增加新的功能层次和模块（Linux 就是一个典型的例子） 开放性：遵循 OSI 国际标准，彼此兼容，方便互联 操作系统的作用 用户角度：作为用户与计算机硬件系统之间的接口 资源管理角度：作为计算机系统个资源的管理者 实现了对计算机资源的抽象 OS 是一组控制和管理计算机硬软件资源合理对各项作业调度以及方便用户使用的系统软件的集合。 操作体系提供三种类型调用接口： ~命令方式~、 ~系统调用方式~、 ~图形窗口方式~ 操作系统的发展过程无操作系统的计算机系统 人工操作方式这种人工操作方式有以下三方面的缺点：(1) 用户独占全机。(2) CPU 等待人工操作。(3) 数据的输入，程序的执行、结果的输出均联机进行 脱机输入/输出(Off-Line I/O)方式优点如下：(1) 减少了 CPU 的空闲时间。 （2） 提高 I/O 速度。 单道批处理操作系统 单道批处理系统的特征(1) 自动性：在顺利的情况下，在磁带上的一批作业能自动地逐个地依次运行，而无需人工干预。(2) 顺序性：磁带上的各道作业是顺序地进入内存的。正常情况下，各道作业的完成顺序与它们进入内存的顺序应相同。(3) 单道性：内存中仅有一道作业运行。最早出现的一种 os 多道批处理操作系统 该系统中，用户所提交的作业都先存放在外存上，并排成一个队列，称为后备队列；然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享 CPU 和系统中的各种资源。从宏观上讲：是并行的从微观上讲：是串行的 多道程序设计的优点：(1) 提高 CPU 的利用率。(2) 可提高内存和 I/O 设备利用率。(3) 增加系统吞吐量。 多道程序设计的缺点：(1) 平均周转时间长(2) 无交互能力 分时操作系统分时系统是指，在一台主机上连接了多个带有显示器和键盘的终端，同时允许多个用户通过自己的终端，以交互方式使用计算机，共享主机中的资源。 分时系统的特征(1) 多路性（同时性）宏观上，多个用户同时工作，共享主机。微观上，内存中多个用户作业轮流使用时间片。(2) 独立性每个用户一个终端，互不干扰，相互独立。(3) 及时性响应时间，应该是人所能接受的等待时间，一般为 2~3 秒(4) 交互性终端用户可以对主机内存中自己的程序进行控制、修改分时与批处理操作系统的区别 目标不同批处理系统：以提高系统资源利用率和作业吞吐能力为目标分时系统：强调及时性，对于联机用户的立即型命令要快速响应 适应作业的性质不同批处理系统：适应已调试好的大型作业分时系统：适应正在调试的小型作业 资源使用率不同批处理系统：可以合理安排不同负载的作业，使资源利用率达到最佳分时系统：能够公平地调配 CPU 和主存资源 作业控制方式不同批处理系统：由用户通过 JCL 书写作业控制流，预先提交，脱机工作分时系统：交互型作业由用户从键盘输入控制命令，以交互方式联机工作 实时操作系统提供及时的响应和高可靠性是其主要特点。（例如银行业务） 操作系统的基本特征三种基本操作系统：批处理系统：批处理具有成批处理的特征分时系统：分时具有交互特征实时系统：实时系统具有实时特征它们同时具有并发、共享、虚拟、异步这四个基本特征，其中并发特征是操作系统最重要的特征，其他三个以并发为前提 并发和共享关系：他们是 OS 两个最基本的特征，又是互为存在条件 共享以并发为前提条件，没有并发，不存在共享，就是“独享” 如果共享资源的访问不能协调好，会影响进程的并发执行，甚至无法实现并发，出现进程死锁的情况 为什么要引入进程 操作系统引入进程的概念（1）从理论角度看：对正在运行的程序过程的抽象（2）从实现角度看：是一种数据结构，目的在于清晰的刻画动态系统的内在规律，有效管理和调度进入计算机系统主存储器运行的程序。 因此，进程既能描述程序的并发执行状态，又是共享资源的一种基本单位。 为什么要引入线程 进程切换（1）进程间进行通信和切换的系统开销大，限制了系统中并发运行的进程的数目（2）进程是操作系统中资源分配和系统调度的基本单位，拥有独立的地址空间和运行环境，从而相关进程间耦合关系差。 解决方案（1）每个进程中包含多个线程，线程是进程中的一条执行路径。（2）把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位（3）线程基本不拥有系统资源，故对它的调度所付出的开销小 操作系统的结构现代操作系统的基本单位：内核、进程、线程、类程、管程 内核 内核(kernel)是一组程序模块，作为可信软件来提供支持进程并发执行的基本功能和基本操作的一组程序模块， 内核通常驻留在内核空间，运行于核心态，具有访问硬设备和所有主存空间的权限，是仅有的能执行特权指令的那部分程序。 在内核的支撑下，机器功能得到扩展、进程运行环境得到改善，安全性得到保证，系统效率得到提高。 单内核 单内核：是一个很大的进程。它的内部又可以被分为若干模块（或者是层次或其它）。其模块间的通讯是通过直接调用其它模块中的函数实现的，而不是消息传递。 微内核 微内核：操作系统仅将所有应用必需的核心功能放入内核，其他功能都在内核之外，由在用户态运行的服务进行实现，通过微内核所提供的消息传递机制完成进程之间的通信。 单内核与微内核的比较单内核：开销会少一些，所以运行效率会高一些。微内核：更灵活一些，若恰当的分配内核空间的内容，可减少开支提高运行小效率 微内核灵活：内核只需要确定出一套标准(类似 API)，随便改周围的一切都可以，都不会相互影响。哪怕改内核，只要不改标准，周围的一切都可以不改变。 微内核稳定性高：毕竟周围的一切都在进程中，哪一部分崩溃，也只是会影响到和这个进程有关的东西。 单内核不灵活：改一点点东西，整个内核就要重新编。 单内核稳定性差：不管哪个地方出问题，整个内核就全崩，内核全崩，电脑也就全崩了。 基本服务和用户接口基本服务 创建程序 执行程序 数据 I/O 信息存取 通信服务 错误检测和处理 还具有另外一些功能:资源分配,统计,保护。 用户接口 程序接口（API）该接口是为用户程序在执行中访问系统资源而设置的，是用户程序取得操作系统服务的惟一途径（ 提供给程序员在编程时使用的接口，是用户程序取得操作系统服务的唯一途径）。它是由一组系统调用组成，每一个系统调用都是一个能完成特定功能的子程序，每当应用程序要求 OS 提供某种服务(功能)时，便调用具有相应功能的系统调用. 操作接口由一组控制命令和（或）作业控制语句组成，是操作系统为用户提供的组织和控制作业执行的手段 系统调用 系统调用是一种中介角色，把用户与硬件隔离开来。 系统调用是应用程序获得操作系统服务的唯一途径 内核的主体是系统调用的集合，内核可以看成是特殊的公共子程序 系统调用的作用（1）内核可以基于权限和规则对资源访问进行裁决，保证系统的安全性（2）系统调用对资源进行抽象，提供一致性接口，避免用户在使用资源时发生错误，且编程效率提高。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理——中央处理器]]></title>
    <url>%2Fblog%2F2019%2F01%2F06%2Fcjse28l3s001zvf6pxvpczvyd%2F</url>
    <content type="text"><![CDATA[CPU 的组成与功能CPU 的基本部分由运算器和控制器 2 个主要部分组成。 控制器控制器由程序计数器、指令寄存器、指令译码器、地址寄存器、时序产生器、操作控制器组成。是发布命令的决策机构。 控制器中的主要寄存器 程序计数器存放指令的地址（当前指令或者下一条指令地址） 地址寄存器(AR，Address Register)用来保存当前 CPU 所访问的内存单元的地址 指令寄存器(IR，Instruction Register)用来保存当前正在执行的一条指令。 指令译码器（ID）对指令寄存器中的操作码字段进行分析，识别该指令规定的操作，向操作控制器发出具体操作的特定信号。控制器的主要作用： 取指令：从主存储器中取出一条指令 指令译码：对当前取得的指令进行分析 控制指令执行：根据分析指令时产生的操作命令和操作数地址形成相应的操作控制序列，通过运算器、存储器以及输入输出设备的执行，实现每条指令的功能。CPU 不断重复执行取指、译码、执行，直至遇到停机或外来的干预。 控制程序和数据的输入与结果输出 处理异常情况和请求 运算器运算器由算术逻辑单元、累加寄存器、数据缓冲寄存器、状态标志寄存器组成。运算器所进行的全部操作都是由控制器发出的控制信号来指挥的。它是执行部件。 算术逻辑单元（ALU）主要负责实现对数据的算术运算和逻辑运算 累加寄存器（AC）暂时存放参加 ALU 运算的操作数据和结果的部件，是一个通用寄存器 数据缓冲寄存器（DR）暂时存放从主存储器、输入/输出设备读来的数据或者准备写入它们的数据数据缓冲寄存器的作用是 ：(1)作为 CPU 和内存、外部设备之间信息传送的中转站；(2)补偿 CPU 和内存、外围设备之间在操作速度上的差别；(3)在单累加器结构的运算器中，数据缓冲寄存器还可兼作为操作数寄存器。 状态标志寄存器用来保存由算术指令和逻辑指令运行或测试的结果而建立的各种条件码内容。如运算结果进位标志、运算结果溢出标志、运算结果为 0 标志、运算结果为负标志等。除此之外，状态标志寄存器还用来保存中断和系统工作状态等信息，以便 CPU 和系统能及时了解机器运行状态和程序运行状态。 CPU 的功能指令控制操作控制时间控制数据加工 操作控制器 数据通路是许多寄存器之间传送信息的通路。信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，都要加以控制。在各寄存器之间建立数据通路的任务，是由称为操作控制器的部件来完成的。 操作控制器的功能根据指令操作码和时序信号，产生各种操作控制信号，以便正确地建立数据通路，从而完成取指令和执行指令的控制。 根据设计方法不同，操作控制器可分为三种： 硬布线控制器是采用时序逻辑技术来实现的； 微程序控制器是采用存储逻辑来实现的； 门阵列控制器前两种方式的组合 时序产生器指令周期 非访问主存储器指令的指令周期直接访问主存储器指令的指令周期间接访问主存储器指令的指令周期程序控制指令的指令周期（见书本） 时序信号的作用和体制 CPU 能很容易通过时序控制信号从时间和空间上识别出是数据还是指令。从时间来说，取指令发生在指令周期的第一个 cpu 周期，即发生在“取指令”阶段，而取数据事件发生在指令周期后面几个 cpu 周期中，即发生在“执行指令”阶段。从空间上来说，如果取出的代码还是指令那么一定送往指令寄存器，如果取出的代码是数据，那么一定送往运算器。 计算机硬件的器件特性决定了时序信号最基本的体制是电位—脉冲制。 时序信号的体制： 时序信号产生器的最基本的结构是一样的，都是由时钟源、环形脉冲发生器、节拍脉冲、读写时序译码逻辑、启停控制逻辑等部分组成 CPU 的控制方式控制方式：形成控制不同操作序列的时序信号的方法 同步控制方式在任何情况下给定的指令在执行时所需的机器周期数和时钟周期数都固定不变的控制方式 异步控制方式每条指令、每个操作控制信号需要多少时间就占用多少时间运行速度快、控制电路复杂 联合控制方式同步和异步的联合 微程序设计技术和微程序控制器微程序设计技术是利用软件方法进行硬件设计的技术采用微程序设计思想的微程序控制器、同组合逻辑控制器相比较，具有规整、灵活、易维护等一系列优点。 基本思想若干条微命令编制成一条微指令，控制实现一步操作就是按照设计解题程序的思路，把操作控制信号编成微指令，并将微指令代码存放到只读存储器里；当机器运行时，一条一条地读出这些微指令，产生计算机所需要的各种操作控制信号，使相应部件执行规定的操作。 微程序设计技术的基本概念 微操作：指令执行时必须完成的基本操作。例如，PC→AR，PC+1→ PC，RAM→IR。 微命令：是组成微指令的最小单位，也就是控制微操作实现的控制信号。一般用于控制数据通路上门的打开/关闭，或者功能选择。 微指令：是一组微命令的集合，用于完成一个功能相对完整的操作。 微程序：微指令的有序集合，用于实现机器指令的功能。 控制存储器（CM）属于 CPU：是存放微程序的存储器。该存储器主要存放控制命令和下一条执行的微指令地址。 微指令寄存器（µIR）用于存放现行微指令微命令字段（微操作控制字段）：提供一步操作所需的微命令。微地址字段（顺序控制字段）：指明后续微地址的形成方式，提供微地址的给定部分 微指令的基本格式：操作控制部分：用来发出指挥计算机工作的控制信号。可以用操作字段的每一位表示一个微命令，位信息为“1”表示发出微命令；位信息为“0”表示不发出微命令。微命令信号既不能来得太早，也不能来得太晚，为此要求这些微命令信号还要加入时间控制。顺序控制部分：用来决定产生下一条微指令的地址。顺序控制字段的若干位直接给出下一条微指令的地址，其余各位则做为判别测试状态的标志，如标志为“0”表示不进行判别测试，直接按顺序控制字段给出的地址取下一条微指令；若标志为“1”表示要进行判别测试，根据测试结果，按要求修改相应的地址位信息，并按修改后的地址取下一条微指令。 微地址形成电路提供两类微地址微程序入口地址：由机器指令操作码形成后续微地址：由微地址字段、现行微地址、运行状态等形成。 微指令周期与 CPU 周期的关系 微指令与机器指令的关系 一条机器指令对应一个微程序，这个微程序是由若干条微指令序列组成的。因此，一条机器指令的功能是由若干条微指令组成的序列来实现的。简言之，一条机器指令所完成的 操作划分成若干条微指令来完成，由微指令进行解释和执行。 从指令与微指令，程序与微程序，地址与微地址的对应关系来看，前者与内存储器有关，后者与控制存储器有关。 每一个 CPU 周期对应一条微指令。 微程序设计微命令编码是指对微指令中的操作控制字段采用的表示方法。通常有以下三种方法 直接表示法其特点是操作控制字段中的 每一位代表一个微命令。这种方法的优点是简单直观，其输出直接用于控制。缺点是微指令字较长，因而使控制存储器容量较大。 编码表示法编码表示法是把一组相斥性的微命令信号组成一个小组(即一个字段) ，然后通过小组(字段）译码器对每一个微命令信号进行译码 ，译码输出作为操作控制信号，结构如图。 混合表示法这种方法是把直接表示法与字段编码法混合使用，以便能综合考虑指令字长、灵活性、速度等要求。 常数字段控制法这种方法在微指令中附设一个常数字段，就象指令中的立即数一样，用它来给某些执行部件直接发送常数。该常数有时作为操作数送入 ALU 参加运算，有时也作为计数器的初值来控制微程序循环次数。 微指令执行的顺序控制问题，实际上是如何确定下一条微指令的地址问题。通常，产生后继微地址有三种方法：1）计数器方式2）增量方式与断定方式相结合3）多路转移方式 微指令格式 水平型微指令一次能定义并执行多个并行操作微命令的微指令，叫做水平型微指令。 垂直型微指令微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能 ，称为垂直型微指令。 水平型微指令与垂直型微指令的比较(1)水平型微指令并行操作能力强，效率高，灵活性强，垂直型微指令则较差。(2)水平型微指令执行一条指令的时间短，垂直型微指令执行时间长。(3)由水平型微指令解释指令的微程序，有微指令字较长而微程序短的特点。垂直型微指令则相反。(4)水平型微指令用户难以掌握，而垂直型微指令与指令比较相似，相对来说，比较容易掌握。 串行/并行微程序控制 串行微程序控制方式（顺序）在串行微程序控制方式中，执行现行微指令的操作与取下一条微指令的操作在时间上是按顺序进行的，所以微指令周期=取微指令的时间+执行微操作的时间，即等于只读存储器的读数周期。 并行微程序控制方式（时间上重叠）就是将取微指令和执行微指令这两类操作在时间上重叠并行进行的方式。由于取微指令和执行微指令的操作是在两个完全不同的部件中执行的，因此，可以将这两部分操作同时进行，以缩短微指令周期。 动态微程序设计 微程序设计有静态微程序设计和动态微程序设计之分。 若计算机的机器指令只有一组微程序，而且这一组微程序设计好之后，一般无需改变而且也不易改变，那么这种微程序设计称为静态微程序设计。 当采用 EPROM 作为控制存储器时，可以通过改变微指令和微程序来改变机器的指令系统，这种微程序设计称为动态微程序设计。 毫微程序设计 毫微程序是用以解释微程序的一种微程序，因此组成毫微程序的毫微指令就可看作是解释微指令的微指令。 采用毫微程序设计的主要目的是减少控制存储器的容量。 采用的是两级微程序设计方法。通常第一级采用垂直微程序，第二级采用水平微程序。 微程序控制器它主要由控制存储器、微指令寄存器和地址转移逻辑三大部分组成。 硬布线控制器 这种方法把控制部件作为产生专门固定时序控制信号的逻辑电路，而此逻辑电路以使用最少元件和取得最高操作速度为设计目标。 因为该逻辑电路是由门电路和触发器构成的复杂树形网络，所以称为硬布线控制器。硬布线控制器由组合逻辑网络 几个问题 如何缩短微指令字的长度？采用混合编码译码控制法 如何减小控制存储器的容量？采用毫微程序设计 如何减少微程序长度？水平型微指令 如何提高微程序的执行速度？水平型微指令 如何易于修改微指令？动态微程序设计 如何增加微程序设计的灵活性？两级微程序设计，第一层垂直型，第二层水平型]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理——指令系统]]></title>
    <url>%2Fblog%2F2019%2F01%2F06%2Fcjse28l320015vf6pa6tvblx7%2F</url>
    <content type="text"><![CDATA[指令格式指令操作码与地址码 指令字（简称指令）即表示一条指令的机器字。 指令格式则是指令字用二进制代码表示的结构形式，由操作码字段和地址码字段组成 操作码字段：指明了指令的操作性质及功能 地址码字段：指明了操作数的地址 不同的指令用操作码字段的不同编码来表示，每一种编码代表一种指令。 操作码组成操作码字段的位数一般取决于计算机指令系统的规模。地址码根据一条指令中有几个操作数地址，可将该指令称为几操作数指令或几地址指令。 指令字长度与扩展方法 指令字长度：一个指令字中包含二进制代码的位数。 机器字长：计算机能直接处理的二进制数据的位数，它决定了计算机的运算精度。 使用多字长指令，目的在于提供足够的地址位来解决访问内存任何单元的寻址问题。其主要缺点是必须两次或多次访问内存以取出一整条指令，降低了 CPU 的运算速度，又占用了更多的存储空间。 指令操作码扩展方法操作码不固定将增加指令译码和分析的难度，使控制器的设计复杂。通常在指令字中用一个固定长度的字段来表示基本操作码，而对于一部分不需要某个地址码的指令，则把它们的操作码的长度扩充到该地址字段。 指令和数据的寻址方式重点掌握书上的例题 指令的寻址方式 顺序的寻址方式指令在内存中式按地址顺序安排的，执行程序时，通常是一条指令接一条指令顺序进行。 跳跃的寻址方式当程序要转移执行的顺序时，指令的寻址就采取跳跃寻址方式。跳跃，又称跳转，是指下条指令的地址码不是由程序计数器给出，而是由本条指令给出。 数据的寻址方式所谓操作数寻址方式，就是形成操作数的有效地址（EA）的方法。指令字中的地址码字段，通常是由形式地址和寻址方式特征位组成的，并不是操作数的有效地址。 隐含寻址在指令中不明显的给出而是隐含着操作数的地址。 立即寻址指令的地址字段指出的不是操作数的地址，而是操作数本身。这种方式的特点是指令执行时间很短，不需要访问内存取数（操作数在地址码字段中）。 寄存器寻址操作数放在 CPU 的通用寄存器中，操作数所在的寄存器编号存放在指令的地址字段 A 中 直接寻址寄存器直接寻址方式：指令地址码字段直接给出所需操作数在通用寄存器中地址编号。存储器直接寻址方式：一般简称直接寻址方式，其指令地址码字段直接给出存放在存储器中操作数的存储地址。 间接寻址间接寻址的情况下，指令地址字段中的形式地址 A 不是操作数的真正地址，而是操作数地址的指示器，A 单元的内容是操作数的有效地址。寄存器间接寻址方式：寄存器间接寻址时，需先访问寄存器，从寄存器读出操作数地址后，再访问存储器才能取得操作数。存储器间接寻址方式：存储器间接寻址时，需访问两次存储器才能取得数据，第一次先从存储器读出操作数地址，第二次才能根据读出的操作数地址再取出真正的操作数。 相对寻址所谓相对寻址方式，是指根据一个基准地址及其相对量来寻找操作数地址的方式PC相对寻址方式，一般简称相对寻址方式，是指将程序计数器 PC的内容（即当前执行指令的地址）与地址码部分给出的位移量(Disp)通过加法器相加，所得之和作为操作数的有效地址的方式。 基址寻址计算机设置一个寄存器，专门用来存放基准地址，该寄存器就是基址寄存器(RB)。RB 既可在 CPU 中专设，也可由指令指定某个通用寄存器担任。基址寻址方式是将 CPU 中基址寄存器 RB 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址。优点是可以扩大寻址能力。同形式地址相比，基址寄存器的位数可以设置得很长，从而可以在较大的存储空间中寻址。 变址寻址变址寻址方式与基址寻址方式计算有效地址的方法很相似，它把 CPU 中某个变址寄存器的内容与偏移量 D 相加来形成操作数有效地址。 堆栈寻址操作数位于存储器中，操作数所在的存储器地址 EA 由堆栈指针寄存器 SP 隐含指出，通常用于堆栈指令。 指令的分类 数据传送指令 算术/逻辑运算指令 移位操作指令 程序控制指令 输入输出指令 字符串处理指令 堆栈操作指令 特权指令 其他指令（状态寄存器置位、复位指令、测试指令、暂停指令，空操作指令，以及其他一些系统控制用的特殊指令。）]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理——存储器及存储系统]]></title>
    <url>%2Fblog%2F2019%2F01%2F04%2Fcjse28l3u0021vf6p3ft7idl9%2F</url>
    <content type="text"><![CDATA[存储器的分类 按存储介质分半导体存储器：如 ram、rom，用作主存磁表面存储器：如磁盘、磁带，用作辅存激光存储器：光盘，用作辅存 按存储方式分随机存储器（RAM）：任何存储单元的内容都能被随机存取，且存取时间和存储单元的物理位置无关串行访问存储器（SAS）：存储单元的内容只能按某种顺序来存取，存取时间与存储单元的物理位置有关，取决于访问存储单元的地址顺序只读存储器（ROM）：对内容只能读不能写入的存储器。 按信息的可保存性分非永久性记忆的存储器：断电后信息即消失的存储器（RAM）永久性记忆的存储器：永久记忆性存储器（ROM） 按在计算机系统中的作用分主存储器、辅助存储器、高速缓存存储器、控制存储器 存储器的性能指标 ： 速度 价格 容量 存储器的分级结构如图所示辅存、主存和缓存的三级存储系统结构，一般来说，“Cache－主存”层次用来弥补主存速度的不足；“主存－辅存”层次用来弥补主存容量的不足。 主存储器主存储器的性能指标 存储容量：在一个存储器中可以容纳的出存储器的单元总数通常称为该存储器的存储容量（单位：字节 B） 存取时间：存储器接受到命令到存储器读（写）出信息的时间 存取周期：连续访问操作过程一次完整存取操作的时间。 存储器带宽：单位时间内存储器所存取的信息量（位/秒，字节/秒） 半导体存储器芯片SRAM：静态随机存取存储器，是随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。DRAM：动态随机存取存储器，是一种半导体内存，主要的作用原理是利用电容内存储电荷的多寡来代表一个二进制比特（bit）是 1 还是 0（电容上电荷的有无）。由于在现实中电容会有漏电的现象，导致电位差不足而使记忆消失，因此除非电容经常周期性地充电，否则无法确保记忆长存。由于这种需要定时刷新的特性，因此被称为“动态”内存。相对来说，静态内存（SRAM）只要存入数据后，纵使不刷新也不会丢失记忆。SRAM 的存取速度快，但集成度低，功耗较大，一般用来组成高速缓冲存储器。DRAM 具有容易集成，位价低，容量大和功耗低等优点。但是存取速度比 SRAM 慢，一般用来组成大容量的主存系统。 动态 MOS 存储器 DRAM 的刷新 采用读出的方式进行刷新，按行来刷新，（行：单个芯片的单个矩阵的行数） 刷新有三种方式：集中式、分散式、异步式半导体只读存储器 MROM(掩模型)：掩模工艺制作, 只能读出, 不能写，可靠性高, 集成度高, 不能重写 PROM: 可一次编程之盾存储器 EPROM: 可擦去可变成只读存储器(用紫外光擦去并且可以重复编程) EEPROM: 电擦去可重写只读存储器 Flash Memoey(闪存存储器)新型的电擦去可编程 ROM, 在 EPROM 功能基础上增加了芯片的点擦除和重新编程能力强特点: 高密度, 可直接执行, 具有 RAM 的读写功能 存储器与 CPU 的连接（见书本和笔记） 位扩展 字扩展 高速缓冲存储器Cache 的功能与基本原理 Cache 是指位于 CPU 和主存之间的一个高速小容量的存储器，一般由 SRAM 构成。 Cache 功能：用于弥补 CPU 和主存之间的速度差异，提高 CPU 访问主存的平均速度。 设置 Cache 的理论基础，是程序访问的局部性原理。 Cache 的内容是主存部分内容的副本，Cache 的功能均由硬件实现，对程序员是透明的。基本原理 CPU 与 Cache 之间的数据交换是以字为单位，而 Cache 与主存之间的数据交换是以块为单位。一个块由若干定长字组成的。 当 CPU 读取主存中一个字时，便发出此字的内存地址到 Cache 和主存。 此时 Cache 控制逻辑依据地址判断此字当前是否在 Cache 中：若在(称为 ~命中~ ），此字立即传送给 CPU；若不在(称为 ~不命中~ ），则用主存读周期把此字从主存读出送到 CPU，与此同时，把含有这个字的整个数据块从主存读出送到 Cache 中。由始终管理 Cache 使用情况的硬件逻辑电路来实现 LRU 替换算法。 主存与 Cache 的地址映射三种方式：直接方式、全相联、组相联 直接映射方式若主存的第 j 块一定映射到 Cache 的第 i 行，Cache 的行号 i 和主存的块号 j 有如下函数关系：i = j mod m（m 是 Cache 中的总行数。优点是硬件简单，成本低。缺点是每个主存块只有一个固定的行位置可存放，容易产生冲突。因此适合大容量 Cache 采用。 全相联映射方式主存中一个块的地址与块的内容一起存于 Cache 的行中，其中块地址存于 Cache 行的标记部分中。这种方法可使主存的一个块直接拷贝到 Cache 中的任意一行上，非常灵活。它的主要缺点是比较器电路难于设计和实现,因此只适合于小容量 Cache 采用。 组相联映射方式这是前两种方式的折衷方案。它把 Cache 存储器分为若干个组，每组包含若干个页面。组间采用直接映像，而组内的页面则采用全相联映像。组相联映射方式中的每组行数 v 一般取值较小，这种规模的 v 路比较器容易设计和实现。而块在组中的排放又有一定的灵活性，冲突减少。 多体交叉存储器 出发点：能够实现同时从存储器取出 n 条指令 特点：通过改进主存的组织方式，在不改变存储器存取周期的情况下，提高存储器的带宽。 结构特点：多体交叉存储器由 M 个的存储体（或称存储模块）组成，每个存储体有相同的容量和存取速度，又有各自独立的地址寄存器、地址译码器、读写电路和驱动电路。 每个模块各自以等同的方式与 CPU 传送信息。CPU 同时访问四个模块，由存储器控制部件控制它们分时使用数据总线进行信息传递。这是一种并行存储器结构。 虚拟存储器基本概念虚拟存储器是建立在主存——辅存物理结构基础之上，由附加硬件装置以及操作系统存储管理软件组成的一种存储体系，它把主存和辅存的地址空间统一编址，形成一个庞大的存储空间。 实地址和虚地址 实地址：实际的主存储器单元的地址，即主存地址，或叫物理地址。 虚地址：虚拟存储器的辅存部分也能让用户象内存一样使用，用户编程时指令地址允许涉及到辅存的空间范围，这种指令地址称为“虚地址”（即虚拟地址），或叫“逻辑地址”。 虚拟存储器的用户程序以虚地址编址并存放在辅存里，程序运行时 CPU 以虚地址访问主存，由辅助硬件找出虚地址和物理地址的对应关系 主存——外存层次和 Cache——主存层次用的地址变换映射方法和替换策略是相同的，都基于程序局部性原理。 虚拟存储器和 Cache 的区别 Cache 存储器采用与 CPU 速度匹配的快速存储元件来弥补主存和 CPU 之间的速度差距；而虚拟存储器的主要功能是弥补了主存和辅存之间的容量差距。 两个存储体系均以信息块作为存储层次之间基本信息的传递单位：Cache 存储器每次传递是定长的的信息块，长度只有几十字节；而虚拟存储器信息块划分方案很多，有页、段等等，长度均在几百 B~几百 KB左右。 CPU 访问快速 Cache 存储器的速度比访问慢速主存快 5~10 倍。虚拟存储器中主存的速度要比辅存快 100~1000 倍以上。 Cache 存储器存取信息的过程、地址变换和替换策略全部用硬件实现。主～辅层次的虚拟存储器基本上由操作系统的存储管理软件辅助一些硬件进行信息块的划分和主～辅存之间的调度。 主存～ Cache 存储体系中 CPU 与 Cache 和主存都建立了直接访问的通路，一旦在主存命中，CPU 将直接访问主存；辅助存储器与 CPU 之间没有直接通路，一旦在主存不命中，只能从辅存调度信息块到主存。同时因为辅存的速度相对 CPU 差距太大，调度需要毫秒级时间，因此 CPU 一般将改换执行另一个程序，等到调度完成后再返回原程序继续工作。 页式虚拟存储器 页是主存物理空间中划分出来的等长的固定区域。 页式虚拟存储系统中，虚拟空间分成页，称为逻辑页；主存空间也分成同样大小的页，称为物理页。 虚存地址分为两个字段：逻辑页号 页内行地址 实存地址也分两个字段：物理页号 页内行地址 ~虚拟存储器地址~到~主存地址~的变换是由放在主存的页表实现的。 页表中每一个虚存逻辑页号有一个表目，表目内容包含该逻辑页所在的主存页面地址(物理页号)，用它作为实存地址的高字段，与虚存地址的页内行地址字段相拼接，产生完整的实主存地址，据此来访问主存。 为了避免页表已保存或已调入主存储器时对主存访问次数的增多，把页表的最活跃部分存放在高速存储器中组成快表。 快表由硬件组成，比页表小得多，只是慢表的小副本。查表时，由逻辑页号同时去查快表和慢表，当在快表中有此逻辑页号时，就能很快地找到对应的物理页号送入实主存地址寄存器。 优点是页面的起点和终点地址是固定的,方便造页表,新页调入主存也很容易掌握，比段式空间浪费小。 缺点是处理、保护和共享都不及段式来得方便。 段式虚拟存储器 段是按照程序的逻辑结构划分成的多个相对独立部分，作为独立的逻辑单位，各个段的长度因程序而异。 虚拟地址由段号和段内地址组成，为了把虚拟地址变换成实主存地址，需要一个段表。 优点是段的逻辑独立性使它易于编译、管理、修改和保护，也便于多道程序共享；某些类型的段具有动态可变长度,允许自由调度以便有效利用主存空间。 缺点是因为段的长度各不相同，起点和终点不定，给主存空间分配带来麻烦，而且容易在段间留下许多空余的零碎存储空间，造成浪费。 段页式虚拟存储器 段页式虚拟存储器是段式虚拟存储器和页式虚拟存储器的结合。 它把程序按逻辑单位分段以后，再把每段分成固定大小的页。 程序对主存的调入调出是按页面进行的，但它又可以按段实现共享和保护，兼备页式和段式的优点。 缺点是在映象过程中需要多次查表。 存储校验技术检错码 奇偶校验包含奇校验和偶校验两种校验。 奇校验约定的编码规律，是让整个校验码（包含有效信息和校验位）中“1”的个数为奇数。 偶校验约定的编码规律，是让整个校验码中“1”的个数为偶数。 这个校验位取“0” 还是取“1”的原则是：若是奇校验，则连同校验位在内编码里含“1”的个数共有奇数个；若是偶校验，则连同校验位在内编码里含“1”的个数是偶数个。 纠错码 常用的纠错码有海明码、循环码等。 只要使用足够的校验位，就可以达到对任何错误的检测和纠错水平。 若需要校正字长 k位的单错，则必须添加 r个校验位，它能够指出k+r个错误及无错误的情况，r必须满足 2 的 r 次方 ≥k+r+1。]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理——运算方法与运算器]]></title>
    <url>%2Fblog%2F2019%2F01%2F04%2Fcjse28l340018vf6p0fed5m1s%2F</url>
    <content type="text"><![CDATA[数值数据的表示 计算机中的数据表示，包括定点数、浮点数、字符、十进制数的表示方法 ; 原码、补码、反码、移码等码制之间的关系以及各码制之间真值数的转换； 原码求补码的方法：正数，不变，即原码=补码负数，符号位不变，数值为取反并加 1 补码中零只有一个：0.0000000 补码 1.0000000 表示负 1 原码 如果机器字长为 n，那么一个数的原码就是用一个 n 位的二进制数，其中最高位为符号位：正数为 0，负数为 1。剩下的 n-1 位表示该数的绝对值 正数的原、反、补码都一样，0 的原码跟反码都有两个，因为这里 0 被分为+0 和-0。 反码 反码就是在原码的基础上，符号位不变其他位按位取反(就是 0 变 1，1 变 0)就可以了 补码 补码也非常的简单，就是在反码的基础上按照正常的加法运算加 1 负数的补码这么记更简单： ~符号位不变，其他的从低位开始，直到遇见第一个 1 之前，什么都不变；遇见第一个 1 后保留这个 1，以后按位取反~ 除此之外，还可以用 [1000_0000]补 表示-128：(-1) + (-127) = [1000_0001]原 + [1111_1111]原 = [1111_1111]补 + [1000_0001]补 = [1000_0000]补-1-127 的结果应该是-128，在用补码运算的结果中， [1000_0000]补 就代表-128。注意，-128 并没有原码和反码表示。 移码 移码最简单了，不管正负数，只要将其补码的符号位取反即可。 数的浮点表示法阶码决定范围，尾数决定精度。 浮点数的规格化为了使浮点表示法有尽可能高的精度，采取的措施之一是增加位数，或者在字长一定的情况下将阶码和尾数所占的位数协调好，措施之二是采用浮点数规格化表示，就是通过调整界面，使其尾数满足以下形式：原码规格化后： 正数为 0.1×……× 的形式，负数为 1.1×……× 的形式。补码规格化后 ： 正数为 0.1×……× 的形式，负数为 1.0×……× 的形式。 非数值数据的表示 ASCII 码有 7 位，总共 128 个，最高位区分是否是汉字 区位码（十六进制）+ 2020H = 国标码 机内码 = 国标码 + 8080H 一个汉字占 2 个字节 16 位机内码。 定点加减法运算溢出判断 双符号位法 进位判断法]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理——概述]]></title>
    <url>%2Fblog%2F2019%2F01%2F04%2Fcjse28l330017vf6pmqx263ik%2F</url>
    <content type="text"><![CDATA[计算机的发展 第五代的计算机是通信、存储、信息处理和人工智能相结合的超巨型计算机。 第六代计算机，作为计算机的核心元件不是传统的电子元件。而是更新的光电子元件、超导电子元件或生物电子元件。 人工智能（artificial intelligence）是计算机模拟人类的智能活动，包括感知、判断、理解、学习、问题求解和图像识别等。 大数据的四大特征：海量的数据规模（volume）、多样的数据类型（variety）、价值密度低（value）、快速的数据处理（velocity）。- 计算机系统的组成一台完整的计算机应包括硬件部分和软件部分 计算机的硬件系统 冯·诺伊曼计算机体系结构：存储器：存放数据和程序（按地址顺序存储）运算器：算术运算和逻辑运算控制器：指挥程序运行，内含程序计数器输入设备：将信息转换成机器能识别的形式输出设备：将结果转换成人们熟悉的形式 冯·诺伊曼思想：硬件系统、二进制、自动顺序执行、指令、程序 存储程序原理：程序设计者事先按一定要求编好程序，把它和数据一起存入存储器内，而机器能自动地按照程序执行一条条指令，这样就可以使全部运算成为真正的自动过程。 运算器和控制器合称 CPU。CPU 和存储器通常组装在一个主板上，合称主机。 计算机中有两股信息在流动：一股是控制信息，其发源地是控制器，它分散流向各个部件；另一股是数据信息，它受控制信息的控制，从一个部件流向另一个部件，边流动边被加工处理。 计算机的软件系统 软件按其功能分为应用软件和系统软件两大类。合称支撑软件。 计算机系统的层次结构。 微程序设计级：是一个实在的硬件级，它由机器硬件直接执行微指令 一般机器级：由微程序解释机器指令系统。硬件级 操作系统级：有操作系统程序实现。混合级 汇编语言级：提供一种符号形式的语言 高级语言级：面向用户，为方便用户编写程序而设置 一条机器语言对应一段微程序 计算机的特点、性能指标及分类计算机的工作特点 快速性 通用性 准确性 逻辑性 计算机的性能指标 基本字长指参与运算的数的基本长度，用二进制位的长短来衡量 主存容量 运算速度用每秒能执行的指令条数来表示，单位是条/秒MFLOPS 每秒执行百万条浮点指令条数 CPU 处理时间]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unix/Linux系统基础]]></title>
    <url>%2Fblog%2F2018%2F12%2F25%2Fcjse28l3o001uvf6pmab478ea%2F</url>
    <content type="text"><![CDATA[一、Unix 操作系统基础1、shellshell 是内核与用户之间的接口，是一个交互的命令解释器 2、unix 目录组织 在 unix 中，一切都是文件，文件组织成目录，目录是一种组织和控制文件访问的很好的方式，用户可以为目录设置权限以允许其他人访问的文件或只允许自己访问 文件类型：1、普通文件2、目录文件3、字符设备文件4、块设备文件 二、Unix 基本命令\$提示符是 bourne shell、korn shell、posix shell 的标准提示符%提示符通常是 c shell 的提示符“#”提示符一般是为系统管理员保留的用分号分割一行中两个命令 1、几种命令 man命令用来查看帮助手册man 4 passwd用来查看 passwd 的手册的第四节的内容 who命令报告有哪些用户已经登陆系统，每一个用户连接的终端和登陆时间的信息。who am i报告本用户的用户名和端口信息。whoami命令报告系统与本地终端关联的用户吗 write命令向当前登陆到同一个系统的用户的终端发送信息并显示，实现了通过终端的交互对话。 echo命令用于向屏幕上打印信息~双引号~ ：可引用除了字符\$、`、\外的任意字符或字符串~单引号~ ：shell 会忽略任何引用值，即屏蔽单引号内的特殊字符的原本含义。~反引号~ ：shell 认为反引号中的内容是一个系统命令 date命令可以用来显示或设定系统的日期与时间，在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记 12date +%Y%m%d20184012/23/18 passwd命令为你的账户设置密码 uname查看当前系统的版本号 2、命令语法 通配符“?”表示任意单个字符“*”表示任何字符“[]”表示括号中的任意一个字符 重定向字符标准输入： &lt;标准输出： &gt; &gt;&gt;在原来文件内容的基础上附加标准错误输出：2&gt; 命令行选项用一个破折线定义命令的不同形式 管道符“|” 完成两程序的连接，例如ps -ef | more常用于过滤、修改或维护命令的输出 后台处理将任务放在后台处理，例如 “&amp;” 3、文件系统目录文件通常是数据的容器，而目录是文件或者其他目录的容器。 /opt 这个目录会用来存放应用程序和产品 /usr/bin 包含的基础的 unix 系统操作和文件处理的命令 /usr/lib 包含应用程序使用的文档和共享的库 /usr/local/bin 存放本地开发的程序的工具（/usr/contrib/bin 存放公用的） /etc 系统配置文件 /stand/vmunix 存放系统内核文件 /tmp 通常作为操作系统的一个临时空间 /dev 存放可以被连接到系统硬件设备的文件，通常被叫做“设备文件” 4、文件权限drwxr-xr-x第一位 l 软连接 d 目录 b 块文件 c 字符 -都不是 ；后 9 位每三位分别是 user、group、other 的权限：read、write、execute 5、文件系统命令 pwd 查看当前目录 ls 查看目录下文件名（ll 会显示详细信息）-a 显示所有文件-d 列出文件描述-l 每一个文件描述属性的长列表-F 在每个目录后面加反斜杠/，在可执行文件后面加星号*-R 递归地列出给出的目录和所有子目录中的文件 cd 进入目录 find 找到文件 mkdir 创建目录 rmdir 删除目录 more 一次一屏的显示 cp 复制文件 cp file1 fiel2-i 会在复制时向你确认是否覆盖旧文件-r 选项可复制目录-p 复制时保留权限 mv 移动或者给文件重命名 touch 创建新文件touch 命令有以下选项：-a time 更改存取(Access)时间为指定的时间-m time 更改修改(Modify)时间为指定的时间-t time 使用指定时间(time)来代替当前时间。-c 如果文件不存在，不创建新文件。 find 路径 -name 文件名 cat 命令主要有三大功能： 1.一次显示整个文件。$ cat filename 2.从键盘创建一个文件。$ cat &gt; filename只能创建新文件,不能编辑已有文件. 3.将几个文件合并为一个文件。$cat file1 file2 &gt; file file 命令 查看文件类型 grep 搜索文件内容 统计文本 wc统计行数、字数、字符数wc -[l,w,c] filename whereis 查找命令-b 仅搜索二进制文件-m 仅搜索帮助文件-s 仅搜索源代码 6、用户和用户组管理有关用户账号的文件： passwd 文件：每一个合法用户的账号对应该文件中的一行记录（登陆名：密码：用户标志号：组标志号：用户的全名或其他描述：主目录：登陆 shell） shadow 文件： /etc/shadow 文件存放用户账户的加密密码信息和密码的有效期。 group 文件：/etc/group 存放系统中的所有组（组名：密码：组标志号：用户列表） 使用 useradd 和 groupadd 命令来添加用户和组；修改组属性：groupmod [-g &lt;新 GID&gt; [-o]][-n &lt;新组名&gt;] &lt;现有组名&gt; 三、管理文件1、lp 命令 lp 命令让用户将文件送往打印队列来打印文件。每个使用 lp 提交的打印请求都会被分配一个唯一的任务标识号（称为一个请求 ID）。lp 命令的语法是：lp [-d dest][-n number] [-o option] –t title [-w][file….]一些 lp 命令的选项：-n number 文件打印的重复的份数（默认是 1）。-d dest 打印请求会被送到的打印机的名字。-t title 在打印输出的标题页中打印标题。-o option 指定你的打印机的具体的选项，例如字体，间距，灰度等等-w 在文件打印完成以后，写一条信息到用户的终端。lpstat 报告已经送往打印机队列的打印请求 2、cancel 命令cancel id [id …] 取消一个有 lp 命令产生的打印机任务cannel printer [ printer…] 取消当前在指定打印机上的打印任务 3、ln 命令ln file1 file2 硬链接文件和原文件指向同样的数据，就像克隆一样，inode 号也相同，当删除原文件时，硬链接文件仍然存在有效。但硬链接文件不同于文件的复制，并没有复制原文件数据。简单说，硬链接就是一个类似于别名的概念。当原来的名字没有了，别名照样可以使用。硬链接指通过索引节点来进行的连接硬链接不可以跨文件系统，不能为目录建硬链接看不出硬链接和文件的区别，属性上都用-表示 软链接和 windows 系统的快捷方式含义一样。软链接和原文件的 inode 不同，该文件的内容是指向原文件的路径信息。软链接就好像是指针一样。而硬链接就是引用。软链接可以跨文件系统属性上用 l 表示 4、文件的权限管理 chmod 改变文件的存取权限 chown 改变一个文件的属主，只有文件的属主和 root 才能更改一个文件的所有权 umask 改变默认的文件存取权限 chgrp 改变一个文件的组 su 转换你的用户的身份 newgrp 转换你的组的身份 四、定制工作环境 alias 为命令设置别名alias dir=&#39;ls&#39; tab 文件名自动补全 history 历史命令，在默认方式下，bash 使用用户主目录下面的文件“.bash_history”来保存历史命令改变存放历史命令的文件# HISTFILE=“/home/mengqc/.myhistory”重新设定能够保留的命令个数# HISTSIZE=600 1、环境变量 使用env命令来查看用户环境变量注意，多数环境变量，都需要export才起作用例如 # export $PATH 与环境变量相关的全局配置文件/etc/bashrc 全局配置/etc/profile 登录 shell 的全局配置 个人配置文件，每个登录用户的 home 目录下有：~/.bshrc~/.bash_profile~/.cshrc 五、vi 编辑器1、开始指令 vi +n filename 进入 vi 并且由文件的第几行开始。 vi +filename 进入 vi 并且由文件的最后一行开始。 vi + /word filename 进入 vi 并且由文件的 word 这个字开始。 vi filename(s) 进入 vi 并且将各指定文件列入名单内，第一个文件先读入。（多文件） vedit 进入 vi 并且在输入方式时会在状态行显示“INSERT MODE”。 2、加数据指令 i 在关标位置开始插入字符，结束时候按 ESC 键。 I 在光标所在行首开始加字，结束时按 ESC 键。 a 在光标位置后开始加字，结束时按 ESC 键。 A 在光标所在行尾部开始加字，结束时按 ESC 键。 o 在光标所在行下插入一空白行并开始加字。 O 在光标所在行上插入一空白行并开始加字。 3、删除指令 x 删除光标处字符。 dw 删除从光标位置开始到单词结束处的字符。 dd 删除当前一整行。 d0 删除从行首到光标位置的字符。 d\$ 或 D 删除从光标位置到行尾的字符。 nx 删除由光标位置起始的 n 个字符（含光标位置） nX 删除由光标位置起始的 n 个字符（不含光标位置）。 ndw 删除光标位置开始的 n 个字符组（word)。 ndd 将光标位置起始的 n 行（整行）删除。 :start,endd 删除文件的第 start 到 end 行。 4、光标移动h 往左移 1 位l 或者 spacebar 往右移 1 位k 向上移 1 行j 向下移 1 行0 移到一行的开始\$ 移到一行的末尾[ 移到文件开始位置] 移到文件结束位置G 移到文件的最后一行nG 或者:n 移到文件的第 n 行Ctrl + u 屏幕上卷半屏Ctrl + d 屏幕下卷半屏Ctrl + b 屏幕上卷一屏Ctrl + f 屏幕下卷一屏 5、查找与替换r 修改光标所指的字符R 从光标位置开始修改，结束时按 ESC 键/text 从光标位置往下找字串 text?text 从光标位置往上找字串 textn 继续找下一个字串（在输入上面的查找指令之后使用）[range]s/old_string/new_string[ /option ] 将指定范围内的字符处替换为新串 6、复制及移动文本nY 复制光标所在位置开始的 n 行数据p 将数据粘贴在光标的下一行P 将数据粘贴在光标的上一行:first,last co dest 将 first 到 last 行的数据复制到目标行(dest）下面:Start,end m dest 将 start 到 end 行的数据移动到目标行（dest)下。 :r filename 将指定文件的内容读入光标所在行下。 六、shell 编程基础1、示例12345678#！ /bin/bash# create a group of filesfor((i=1;i&lt;=10;i++))do touch tt$i echo this is tt$i &gt;&gt; tt$idonels -l tt* 2、执行 shell 脚本的基本方法 source test.sh sh test.sh 12* chmod 755 test.sh ./test.sh 3、变量 定义变量变量名=字符串 【注意，等号左右无空格】 如果变量值须出现在长字符串的开头或者中间，为了使变量名与其后的字符区分开，避免 shell 把它与其它字符混在一起视为一个新变量，则应该用花括号将该变量名括起来。 命令替换除了反引号的另一种形势： $(pwd) 声明一个数组：declare -a 数组名定义数组： a=(1 2 3 4 .... n)其中，各个值之间以空格分开。读取数组元素值：echo ${数组名[下标]} 若没有给出数组元素的下标，则数组名表示下标为 0 的数组元素 逻辑操作符 &amp;&amp; ||cmd1 &amp;&amp; cmd2 仅当命令 cmd1 执行成功时，才会执行命令 cmd2。cmd1 || cmd2 仅当命令 cmd1 执行失败时，才会执行命令 cmd2。 位置参数 0,1,2,……命令行实参与脚本中位置变量的对应关系如下所示：exam1 m1 m2 m3 m4$0 $1 $2 $3 $4 $5 $6 $7 $8 $9 ${10} ${11}引用它们的方式依次是$0, $1, $2, …, $9, ${10}, ${11}等。其中，\$0 始终表示命令名或 shell 脚本名。使用 set 命令为位置参数赋值 特殊变量$# 表示命令行上实际参数的个数(不包括shell程序名本身)$ 表示命令行实际给出的所有实参字符串\$@ 表示命令行实际给出的所有实参字符串 注意:\$和$@基本功能相同，但是当两侧有双引号时则存在差别!即:① “$*”把实际给出的所有实参当作一个整体，即一个字符串。② “\$@”把实际给出的每个实参当作一个字符串，即多个字符串。 4、算术运算12345678910111213a=4;b=3((c=a+b))echo $c--------------a=4;b=3let &quot;c=b-a&quot;echo $c--------------expr 4 + 37a=`expr 4 + 3`echo $a7 在算术表达式中，变量名可以直接使用，不需要加\$使用 expr 命令进行算术运算，运算符两侧必须有空格-f 是否是文件-d 是否是目录 5、函数 示例 12345678910111213ave()&#123; sum=0; for((i=0;i&lt;=n;i++)) do ((sum=sum+a[i])) done ((sum=sum/n)) echo $sun&#125;n=5a=(90 82 84 72 61)ave 七、系统管理1、前、后台执行 命令行末尾，加 &amp; 字符，作业放到后台执行 组合键【ctrl -z】：把正在前台执行的作业挂起，并置于后台 fg 命令：fg &lt;作业号&gt;把后台作业调到前台执行 bg 命令：bg &lt;作业号&gt;让后台挂起的作业继续在后台执行 jobs 命令： 了解当前作业情况 nohup 命令 用户退出后作业继续执行 2、查看进程ps 命令查看进程，常用格式： ps -ef ps aux ps -ef | grepgrep: -n, -v, -iand -c.-c显示每个文件中匹配的行数-i不分大小写-n显示匹配行的行号-v显示不匹配的行（匹配的行不显示）例如 ps –ef|grep -i python|grep –v grep 3、有过滤作用的命令 head –n 20 /etc/passwd tail –n 20 /etc/passwd tail –f /log/xxx.log 查看正在改变的日志 more less wc 统计行、字、字符等 既显示结果，又存入文件，用 tee 实现 ls /home | tee dir.list- 4、备份与压缩 tar-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 -z：有 gzip 属性的-j：有 bz2 属性的-Z：有 compress 属性的-v：显示所有过程-O：将文件解开到标准输出 下面的参数-f 是必须的 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 gzip gunzip unzip 5、网络命令 ping 命令ping[选项] 目的地 ifconfig 用来配置一个网络接口 123456789* 示例：## 显示所有当前活动的网络接口的情况。ifconfig## 显示指定网络接口eth0的情况。ifconfig eth0## 配置一个以太网接口，以给定IP地址定义这个网络接口的地址。同时，ifconfig命令自动地创建一个标准的广播地址和子网掩码。ifconfig eth0 211.68.38.133## 指定以太网卡eth0的IP地址为211.68.38.133，广播地址为211.68.38.255,子网掩码为255.255.255.0。ifconfig eth0 211.68.38.133 broadcast 211.68.38.255 netmask 255.255.255.0 netstat 命令 统计 TCP/IP 网络协议的连接。netstat 显示当前已经创建的连接netstat -nr 将显示路由表 route 命令route 命令为数据传递所需的网络连接配置路由信息。]]></content>
      <tags>
        <tag>Unix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊JavaWeb项目后端和前端的交互]]></title>
    <url>%2Fblog%2F2018%2F11%2F27%2Fcjse28l300013vf6pqryf4jy7%2F</url>
    <content type="text"><![CDATA[最近在做学校老师的一个钢管租赁网站的项目，我负责前端的开发。再加上期中考试和各种各样的作业博客也是好久没有更新了（=·=好吧其实是我懒）言归正传，这也算是我第一次参加正式的开发项目，前前后后改了不少次，但确实是学到了很多东西，这和自己平时在网上看看博客写写demo完全是不一样的。这个项目的后台是很早就已经开发得差不多了的。项目采取前后端代码分离的架构，即前端是完全的html格式文件，并非jsp模版文件，数据渲染一律采用ajax方式请求后端获取。今天就来聊一聊JavaWeb项目后端和前端的交互问题，一是增强记忆，二来最近身边的同学也在学习JavaWeb的开发（好像都很懵逼的样子，其实我也只了解一些皮毛） 后端Controller的编写现在jave web后端的主流框架为SSM（Spring SpringMVC Mybatis）或者是SpringBoot + Mybatis。它们都是以MVC为基础的框架，在前后端代码分离的项目中，编写Controller层简单粗暴的说就是设计接口以便前端调用。下面是一段SpringBoot中Controller层的代码：1234567891011121314@Controller@RequestMapping(&quot;/api&quot;)public class DemoController &#123; @RequestMapping(value=“/getinfo”,method=RequestMethod.GET) @ResponseBody private Map&lt;String,Object&gt; getInfo()&#123; Map&lt;String,Object&gt; modelMap = new HashMap&lt;String,Object&gt;(); ... ... ... (调用service层的接口） return modelMap; &#125;&#125; 这就是一个可以通过get方式请求的接口，运行项目，访问http://localhost:8080/projectname/api/getinfo 便可以获取json格式的数据。如果是post方式的请求，那么将代码@RequestMapping(value=“/getinfo”,method=RequestMethod.GET)中的GET改为POST，并使getInfo方法接收一个参数HttpServletRequest request ，然后在方法内处理请求体获取需要的数据便可（具体处理在这里不详述） 前端ajax调用接口这里便不仔细解释了，给出get与post两种方式的ajax请求模版（使用jquery）具体的参数大家可以自行谷歌了解。GET方式：1234$.getJSON(initUrl, function(data) &#123; ... ... &#125;); POST方式：12345678910111213141516$.ajax(&#123; url : Url, type : ‘POST’, data : formData, contentType : false, processData : false, cache : false, success : function(data) &#123; if (data.success) &#123; $.toast(‘提交成功！’); &#125; else &#123; $.toast(‘提交失败！’ + data.errMsg); console.log(data.errMsg); &#125; &#125;&#125;);]]></content>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当你在地址栏输入了一行网址……]]></title>
    <url>%2Fblog%2F2018%2F10%2F16%2Fcjse28l2w000vvf6pm0lvokmi%2F</url>
    <content type="text"><![CDATA[当你在浏览器的地址栏输入了一行网址，并回车了之后，浏览器到底做了什么呢？ 先笼统的讲一下：浏览器通过 DNS 解析你输入的网址（ URL ）根据网址中的域名（Domain）部分也就是www.xxxxx.com获取域名对应的IP地址，然后通过基于 TCP/IP 协议的 http 协议发送请求到服务器，服务器响应请求返回数据，浏览器接收数据解析并 渲染 到页面。 我们总结出几个关键词： DNS解析 URL TCP/IP HTTP协议 HTTP请求发起和响应 页面渲染的过程 DNS解析DNS:Domain Name Server，域名服务器。是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。IP地址其实就是一串乱七八糟的数据用户很难记住，但是域名就不一样了，比如谷歌的google.com，百度的baidu.com 简单易记。所以为了处理这个问题，就需要用域名去映射IP地址。因此，当用户在浏览器输入https://www.baidu.com 回车时，它经历了以下步骤： 1.浏览器根据地址去本身缓存中查找dns解析记录，如果有，则直接返回IP地址，否则浏览器会查找操作系统中（hosts文件）是否有该域名的dns解析记录，如果有则返回。2.如果浏览器缓存和操作系统hosts中均无该域名的dns解析记录，或者已经过期，此时就会向域名服务器发起请求来解析这个域名。3.请求会先到LDNS（本地域名服务器），让它来尝试解析这个域名，如果LDNS也解析不了，则直接到根域名解析器请求解析4.根域名服务器给LDNS返回一个所查询余的主域名服务器（gTLDServer）地址。5.此时LDNS再向上一步返回的gTLD服务器发起解析请求。6.gTLD服务器接收到解析请求后查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是你注册的域名服务器（比如阿里dns、腾讯dns等）7.Name Server域名服务器会查询存储的域名和IP的映射关系表，正常情况下都根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器8.返回该域名对应的IP和TTL值，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间有TTL值控制。9.把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。 URLURL：Uniform Resource Locator 统一资源定位符。说白了就是网络上用来标识具体资源的一个地址，包含了用户查找该资源的信息，HTTP使用它来传输数据和建立连接。一个URL有以下组成部分： 1. 协议 2. 服务器地址（域名或IP+端口） 3. 路径 4. 文件名 TCP/IP协议TCP：Transmission Control Protocol， 传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。双方建立TCP连接需要经历三次握手： 1.客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认。2.服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。3.客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 上面几个状态码的解释： 1.SYN:synchronous 建立联机2.ACK:acknowledgement 确认3.SYN_SENT:请求连接4.SYN_RECV:服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态。再进一步接收到客户端的ACK就进入ESTABLISHED状态。TCP连接时并不携带数据 HTTP协议HTTP协议：Hypertext Transfer Protocol 也叫超文本传送协议 ，它是一种基于TCP/IP协议栈、在表示层和应用层上的协议（TCP在传输层的协议），通俗一点说就是TCP/IP是位于传输层上的一种协议，用于在网络中传输数据；HTTP协议是应用层协议，基于TCP协议，用于包装数据，程序使用它进行通信，可以简单高效的处理通信中数据的传输和识别处理。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局笔记]]></title>
    <url>%2Fblog%2F2018%2F10%2F16%2Fcjse28l250002vf6p74i6kgin%2F</url>
    <content type="text"><![CDATA[一、盒模型 ie 盒模型算上 border、padding 及自身（不算 margin），标准的只算上自身窗体的大小 css 设置方法如下： 1234/* 标准模型 */box-sizing:content-box; /*IE模型*/box-sizing:border-box; margin、border、padding、content 由外到里 最常用的获得宽高的方式dom.offsetWidth/offsetHeight 各种获得宽高的方式 获取屏幕的高度和宽度（屏幕分辨率）：window.screen.height/width 获取屏幕工作区域的高度和宽度（去掉状态栏）window.screen.availHeight/availWidth 网页全文的高度和宽度：document.body.scrollHeight/Width 滚动条卷上去的高度和向右卷的宽度：document.body.scrollTop/scrollLeft 网页可见区域的高度和宽度（不加边线）：document.body.clientHeight/clientWidth 网页可见区域的高度和宽度（加边线）：document.body.offsetHeight/offsetWidth 二、居中方式 水平居中内联元素：inline, 内联块 inline-block, 内联表 inline-table, inline-flex 元素及 img,span,button 等text-align:center;不定宽块元素居中：margin:0 auto;//且需要设置父级宽度通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。 123456789.wrap&#123; float:left; position:relative; left:50%; clear:both;&#125;.wrap-center&#123; left:-50%;&#125; 垂直居中单行内联(inline-)元素垂直居中 通过设置内联元素的高度(height)和行高(line-height)相等，从而使元素垂直居中。 12height: 120px;line-height: 120px; 利用表布局 12345678.father &#123; display: table;&#125;.children &#123; display: table-cell; vertical-align: middle; text-align: center;&#125; flex 布局 12345.center-flex &#123; display: flex; flex-direction: column;//上下排列 justify-content: center;&#125; 绝对布局方式已知高度 123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; height: 100px; margin-top: -50px;&#125; 未知高度 12345678.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 垂直水平居中flex 方式 12345.parent &#123; display: flex; justify-content: center; align-items: center;&#125; grid 方式 1234567.parent &#123; height: 140px; display: grid;&#125;.child &#123; margin: auto;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客部署秘籍]]></title>
    <url>%2Fblog%2F2018%2F10%2F12%2Fcjse28l2s000lvf6pzsdcutfw%2F</url>
    <content type="text"><![CDATA[摘要Hexo 是用 Node.js 开发的一个静态站点生成器（Static Site Generator），支持 Markdown 语法写作，有着强大的插件系统，而且性能优异。本文将记录如何将hexo在本地搭建的博客部署到阿里云的Ubuntu16.04服务器上。（通过云服务器上的私有 Git 仓库部署到 Web 服务器目录下） 服务端配置在云服务器上安装 Git 和 Nginx 两个必备的软件包。Git 用于版本管理和部署，Nginx 用于静态博客托管。12sudo apt-get updatesudo apt-get install git nginx Git 配置在 /var/repo/ 下，创建一个名为 hexo_static 的裸仓库（bare repo）。如果没有 /var/repo 目录，需要先创建；然后修改目录的所有权和用户权限，之后 ubuntu 用户都具备/var/repo 目录下所有新生成的目录和文件的权限。123sudo mkdir /var/repo/sudo chown -R $USER:$USER /var/repo/sudo chmod -R 755 /var/repo/ 初始化git仓库12cd /var/repo/git init --bare hexo_static.git 配置 Nginx 托管文件目录接下来，创建 /var/www/hexo 目录，用于 Nginx 托管，并修改权限。123sudo mkdir -p /var/www/hexosudo chown -R $USER:$USER /var/www/hexosudo chmod -R 755 /var/www/hexo 修改 Nginx 的 default 设置：1sudo vim /etc/nginx/sites-available/default 将其中的 root 指令指向 /var/www/hexo 目录123456789... server &#123; listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /var/www/hexo; # 需要修改的部分 index index.html index.htm;... 保存并退出文件。如果以后购买并备案域名之后，可以再将配置中的 default_server 修改为你的域名。最后，重启 Nginx 服务，使得改动生效。 创建Git钩子接下来，在服务器上的裸仓库 hexo_static 创建一个钩子，在满足特定条件时将静态 HTML 文件传送到 Web 服务器的目录下，即 /var/www/hexo。在自动生成的 hooks 目录下创建一个新的钩子文件：1vim /var/repo/hexo_static.git/hooks/post-receive 在该文件中添加两行代码，指定 Git 的工作树（源代码）和 Git 目录（配置文件等）。12#!/bin/bashgit --work-tree=/var/www/hexo --git-dir=/var/repo/hexo_static.git checkout -f 保存并退出文件，并让该文件变为可执行文件。1chmod +x /var/repo/hexo_static.git/hooks/post-receive 当当当！！！到这里服务器的配置就完成啦！ 下面来配置_config.yml中的deploy选项 deploy配置首先修改URL为自己的域名或者公网ip地址，比如我的就是www.jinminrui.cn然后修改deploy1234deploy: type: git repo: root@47.100.221.250（云服务器的IP地址）:/var/repo/hexo_static branch: master 最后！一键部署到位！hexo generate &amp;&amp; hexo deploy]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记]]></title>
    <url>%2Fblog%2F2018%2F10%2F12%2Fcjse28l1z0000vf6pqwizzpkp%2F</url>
    <content type="text"><![CDATA[#git#subversion——集中型版本管理系统 git——分散型版本管理系统 Git 基本命令1、git init —— 初始化仓库2、git status —— 查看仓库状态3、git add —— 向暂存区中添加文件4、git commit —— 保存仓库的历史记录5、git log——查看提交日志6、git diff——查看更改前后的差别7、git checkout -b [name] —— 以当前 master 分支创建新的分支 Pull RequestPull Request 是自己修改源代码后，请求对方仓库采纳该修改时采取的一种行为。]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-Router基础]]></title>
    <url>%2Fblog%2F2018%2F10%2F12%2Fcjse28l2q000jvf6pvoaky795%2F</url>
    <content type="text"><![CDATA[Vue-Router路由中有三个基本的概念 route, routes, router。 1、 route，它是一条路由，由这个英文单词也可以看出来，它是单数， Home 按钮 =&gt; home 内容， 这是一条 route, about 按钮 =&gt; about 内容， 这是另一条路由。 2、 routes 是一组路由，把上面的每一条路由组合起来，形成一个数组。[{home 按钮 =&gt;home 内容 }， { about 按钮 =&gt; about 内容}] 3、router 是一个机制，相当于一个管理者，它来管理路由。因为 routes 只是定义了一组路由，它放在哪里是静止的，当真正来了请求，怎么办？ 就是当用户点击 home 按钮的时候，怎么办？这时 router 就起作用了，它到 routes 中去查找，去找到对应的 home 内容，所以页面中就显示了 home 内容。 4、客户端中的路由，实际上就是 dom 元素的显示和隐藏。当页面中显示 home 内容的时候，about 中的内容全部隐藏，反之也是一样。客户端路由有两种实现方式：基于 hash 和基于 html5 history api. vue-router 中，首先在 routes 数组中定义所需要的 route。 然后创建 router 对路由进行管理，它是由构造函数 new vueRouter() 创建，接受 routes 参数 最后将 router 实例注入到 vue 根实例中,就可以使用路由了执行过程：当用户点击 router-link 标签时，会去寻找它的 to 属性， 它的 to 属性和 js 中配置的路径{ path: ‘/home’, component: Home} path 一一对应，从而找到了匹配的组件， 最后把组件渲染到 标签所在的地方。所有的这些实现才是基于 hash 实现的。 编程式导航：这主要应用到按钮点击上。当点击按钮的时候，跳转另一个组件, 这只能用代码，调用`rourter.push()` 方法。 当们把router 注入到根实例中后，组件中通过 this.$router 可以获取到router, 所以在组件中使用 this.$router.push(&quot;home”)就可以跳转到 home 界面]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Vue生命周期]]></title>
    <url>%2Fblog%2F2018%2F10%2F12%2Fcjse28l2v000tvf6p1g8ncev1%2F</url>
    <content type="text"><![CDATA[vue 提供了如下的钩子函数供我们在 vue 生命周期的不同时刻调用： beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed 1、在 beforeCreate 和 created 钩子函数之间的生命周期在这个生命周期之间，进行初始化事件，进行数据的观测，可以看到在 created 的时候数据已经和 data 属性进行绑定（放在 data 中的属性当值发生改变的同时，视图也会改变）。~注意看下：此时还是没有 el 选项~ 2、created 钩子函数和 beforeMount 间的生命周期 首先会判断对象是否有 el 选项。如果有的话就继续向下编译，如果没有 el 选项，则停止编译，也就意味着停止了生命周期，直到在该 vue 实例上调用 vm.\$mount(el)。template 参数对生命周期的影响：（1）如果 vue 实例对象中有 template 参数选项，则将其作为模板编译成 render 函数。（2）如果没有 template 选项，则将外部 HTML 作为模板编译。（3）可以看到 template 中的模板优先级要高于 outer HTML 的优先级。在 vue 对象中还有一个 render 函数，它是以 createElement 作为参数，然后做渲染操作，而且我们可以直接嵌入 JSX. 123456new Vue(&#123; el: &apos;#app&apos;, render: function(createElement) &#123; return createElement(&apos;h1&apos;, &apos;this is createElement&apos;) &#125;&#125;) 综合排名优先级：render 函数选项 &gt; template 选项 &gt; outer HTML. 3、beforeMount 和 mounted 钩子函数间的生命周期此时是给 vue 实例对象添加\$el 成员，并且替换掉挂在的 DOM 元素。 4、mounted在 mounted 之前 h1 中还是通过进行占位的，因为此时还有挂在到页面上，还是 JavaScript 中的虚拟 DOM 形式存在的。在 mounted 之后可以看到 h1 中的内容发生了变化。 5、beforeUpdate 钩子函数和 updated 钩子函数间的生命周期当 vue 发现 data 中的数据发生了改变，会触发对应组件的重新渲染，先后调用 beforeUpdate 和 updated 钩子函数。在 beforeUpdate,可以监听到 data 的变化但是 view 层没有被重新渲染，view 层的数据没有变化。等到 updated 的时候 view 层才被重新渲染，数据更新。]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
</search>
