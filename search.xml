<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo个人博客部署秘籍]]></title>
    <url>%2F2018%2F10%2F12%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%A7%98%E7%B1%8D%2F</url>
    <content type="text"><![CDATA[摘要Hexo 是用 Node.js 开发的一个静态站点生成器（Static Site Generator），支持 Markdown 语法写作，有着强大的插件系统，而且性能优异。本文将记录如何将hexo在本地搭建的博客部署到阿里云的Ubuntu16.04服务器上。（通过云服务器上的私有 Git 仓库部署到 Web 服务器目录下） 服务端配置在云服务器上安装 Git 和 Nginx 两个必备的软件包。Git 用于版本管理和部署，Nginx 用于静态博客托管。12sudo apt-get updatesudo apt-get install git nginx Git 配置在 /var/repo/ 下，创建一个名为 hexo_static 的裸仓库（bare repo）。如果没有 /var/repo 目录，需要先创建；然后修改目录的所有权和用户权限，之后 ubuntu 用户都具备/var/repo 目录下所有新生成的目录和文件的权限。123sudo mkdir /var/repo/sudo chown -R $USER:$USER /var/repo/sudo chmod -R 755 /var/repo/ 初始化git仓库12cd /var/repo/git init --bare hexo_static.git 配置 Nginx 托管文件目录接下来，创建 /var/www/hexo 目录，用于 Nginx 托管，并修改权限。123sudo mkdir -p /var/www/hexosudo chown -R $USER:$USER /var/www/hexosudo chmod -R 755 /var/www/hexo 修改 Nginx 的 default 设置：1sudo vim /etc/nginx/sites-available/default 将其中的 root 指令指向 /var/www/hexo 目录123456789... server &#123; listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /var/www/hexo; # 需要修改的部分 index index.html index.htm;... 保存并退出文件。如果以后购买并备案域名之后，可以再将配置中的 default_server 修改为你的域名。最后，重启 Nginx 服务，使得改动生效。 创建Git钩子接下来，在服务器上的裸仓库 hexo_static 创建一个钩子，在满足特定条件时将静态 HTML 文件传送到 Web 服务器的目录下，即 /var/www/hexo。在自动生成的 hooks 目录下创建一个新的钩子文件：1vim /var/repo/hexo_static.git/hooks/post-receive 在该文件中添加两行代码，指定 Git 的工作树（源代码）和 Git 目录（配置文件等）。12#!/bin/bashgit --work-tree=/var/www/hexo --git-dir=/var/repo/hexo_static.git checkout -f 保存并退出文件，并让该文件变为可执行文件。1chmod +x /var/repo/hexo_static.git/hooks/post-receive 当当当！！！到这里服务器的配置就完成啦！ 下面来配置_config.yml中的deploy选项 deploy配置首先修改URL为自己的域名或者公网ip地址，比如我的就是www.jinminrui.cn然后修改deploy1234deploy: type: git repo: root@47.100.221.250（云服务器的IP地址）:/var/repo/hexo_static branch: master 最后！一键部署到位！hexo generate &amp;&amp; hexo deploy]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记]]></title>
    <url>%2F2018%2F10%2F12%2FGit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[#git#subversion——集中型版本管理系统git——分散型版本管理系统 Git 基本命令1、git init —— 初始化仓库2、git status —— 查看仓库状态3、git add —— 向暂存区中添加文件4、git commit —— 保存仓库的历史记录5、git log——查看提交日志6、git diff——查看更改前后的差别7、git checkout -b [name] —— 以当前master分支创建新的分支 Pull RequestPull Request 是自己修改源代码后，请求对方仓库采纳该修改时采取的一种行为。]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-Router基础]]></title>
    <url>%2F2018%2F10%2F12%2FVue-Router%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Vue-Router路由中有三个基本的概念 route, routes, router。 1、 route，它是一条路由，由这个英文单词也可以看出来，它是单数， Home按钮 =&gt; home内容， 这是一条route, about按钮 =&gt; about 内容， 这是另一条路由。 2、 routes 是一组路由，把上面的每一条路由组合起来，形成一个数组。[{home 按钮 =&gt;home内容 }， { about按钮 =&gt; about 内容}] 3、router 是一个机制，相当于一个管理者，它来管理路由。因为routes 只是定义了一组路由，它放在哪里是静止的，当真正来了请求，怎么办？ 就是当用户点击home 按钮的时候，怎么办？这时router 就起作用了，它到routes 中去查找，去找到对应的 home 内容，所以页面中就显示了 home 内容。 4、客户端中的路由，实际上就是dom 元素的显示和隐藏。当页面中显示home 内容的时候，about 中的内容全部隐藏，反之也是一样。客户端路由有两种实现方式：基于hash 和基于html5 history api. vue-router中，首先在routes数组中定义所需要的route。 然后创建router 对路由进行管理，它是由构造函数 new vueRouter() 创建，接受routes 参数 最后将router 实例注入到 vue 根实例中,就可以使用路由了 执行过程：当用户点击 router-link 标签时，会去寻找它的 to 属性， 它的 to 属性和 js 中配置的路径{ path: ‘/home’, component: Home} path 一一对应，从而找到了匹配的组件， 最后把组件渲染到 标签所在的地方。所有的这些实现才是基于hash 实现的。 编程式导航：这主要应用到按钮点击上。当点击按钮的时候，跳转另一个组件, 这只能用代码，调用rourter.push() 方法。 当们把router 注入到根实例中后，组件中通过 this.$router 可以获取到router, 所以在组件中使用this.$router.push(&quot;home”)就可以跳转到home界面]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Vue生命周期]]></title>
    <url>%2F2018%2F10%2F12%2F%E5%85%B3%E4%BA%8EVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[vue提供了如下的钩子函数供我们在vue生命周期的不同时刻调用： beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed 1、在beforeCreate和created钩子函数之间的生命周期在这个生命周期之间，进行初始化事件，进行数据的观测，可以看到在created的时候数据已经和data属性进行绑定（放在data中的属性当值发生改变的同时，视图也会改变）。~注意看下：此时还是没有el选项~ 2、created钩子函数和beforeMount间的生命周期 首先会判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。template参数对生命周期的影响：（1）如果vue实例对象中有template参数选项，则将其作为模板编译成render函数。（2）如果没有template选项，则将外部HTML作为模板编译。（3）可以看到template中的模板优先级要高于outer HTML的优先级。在vue对象中还有一个render函数，它是以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX.123456new Vue(&#123; el: &apos;#app&apos;, render: function(createElement) &#123; return createElement(&apos;h1&apos;, &apos;this is createElement&apos;) &#125;&#125;) 综合排名优先级：render函数选项 &gt; template选项 &gt; outer HTML. 3、beforeMount和mounted 钩子函数间的生命周期此时是给vue实例对象添加$el成员，并且替换掉挂在的DOM元素。 4、mounted在mounted之前h1中还是通过进行占位的，因为此时还有挂在到页面上，还是JavaScript中的虚拟DOM形式存在的。在mounted之后可以看到h1中的内容发生了变化。 5、beforeUpdate钩子函数和updated钩子函数间的生命周期当vue发现data中的数据发生了改变，会触发对应组件的重新渲染，先后调用beforeUpdate和updated钩子函数。在beforeUpdate,可以监听到data的变化但是view层没有被重新渲染，view层的数据没有变化。等到updated的时候 view层才被重新渲染，数据更新。]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
</search>
