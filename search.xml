<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[当你在地址栏输入了一行网址……]]></title>
    <url>%2F2018%2F10%2F16%2Fcjnbrv3rp000bha6p2xo2qzgs%2F</url>
    <content type="text"><![CDATA[当你在浏览器的地址栏输入了一行网址，并回车了之后，浏览器到底做了什么呢？ 先笼统的讲一下：浏览器通过 ~DNS~ 解析你输入的网址（ ~URL~ ）根据网址中的域名（Domain）部分也就是www.xxxxx.com获取域名对应的IP地址，然后通过基于 ~TCP/IP~ 协议的 ~http~ 协议发送请求到服务器，服务器响应请求返回数据，浏览器接收数据解析并 ~渲染~ 到页面。 我们总结出几个关键词： DNS解析 URL TCP/IP HTTP协议 HTTP请求发起和响应 页面渲染的过程 DNS解析DNS:Domain Name Server，域名服务器。是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。IP地址其实就是一串乱七八糟的数据用户很难记住，但是域名就不一样了，比如谷歌的google.com，百度的baidu.com 简单易记。所以为了处理这个问题，就需要用域名去映射IP地址。因此，当用户在浏览器输入https://www.baidu.com 回车时，它经历了以下步骤： 浏览器根据地址去本身缓存中查找dns解析记录，如果有，则直接返回IP地址，否则浏览器会查找操作系统中（hosts文件）是否有该域名的dns解析记录，如果有则返回。 如果浏览器缓存和操作系统hosts中均无该域名的dns解析记录，或者已经过期，此时就会向域名服务器发起请求来解析这个域名。 请求会先到LDNS（本地域名服务器），让它来尝试解析这个域名，如果LDNS也解析不了，则直接到根域名解析器请求解析 根域名服务器给LDNS返回一个所查询余的主域名服务器（gTLDServer）地址。 此时LDNS再向上一步返回的gTLD服务器发起解析请求。 gTLD服务器接收到解析请求后查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是你注册的域名服务器（比如阿里dns、腾讯dns等） Name Server域名服务器会查询存储的域名和IP的映射关系表，正常情况下都根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器 返回该域名对应的IP和TTL值，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间有TTL值控制。 把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。 URLURL：Uniform Resource Locator 统一资源定位符。说白了就是网络上用来标识具体资源的一个地址，包含了用户查找该资源的信息，HTTP使用它来传输数据和建立连接。一个URL有以下组成部分： 1. 协议 2. 服务器地址（域名或IP+端口） 3. 路径 4. 文件名 TCP/IP协议TCP：Transmission Control Protocol， 传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。双方建立TCP连接需要经历三次握手： 1.客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认。2.服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。3.客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 上面几个状态码的解释： 1.SYN:synchronous 建立联机2.ACK:acknowledgement 确认3.SYN_SENT:请求连接4.SYN_RECV:服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态。再进一步接收到客户端的ACK就进入ESTABLISHED状态。TCP连接时并不携带数据 HTTP协议HTTP协议：Hypertext Transfer Protocol 也叫超文本传送协议 ，它是一种基于TCP/IP协议栈、在表示层和应用层上的协议（TCP在传输层的协议），通俗一点说就是TCP/IP是位于传输层上的一种协议，用于在网络中传输数据；HTTP协议是应用层协议，基于TCP协议，用于包装数据，程序使用它进行通信，可以简单高效的处理通信中数据的传输和识别处理。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局笔记]]></title>
    <url>%2F2018%2F10%2F16%2Fcjnbrv3r80000ha6pkw0hqbt6%2F</url>
    <content type="text"><![CDATA[一、盒模型 ie盒模型算上border、padding及自身（不算margin），标准的只算上自身窗体的大小 css设置方法如下：1234/* 标准模型 */box-sizing:content-box; /*IE模型*/box-sizing:border-box; margin、border、padding、content由外到里 最常用的获得宽高的方式dom.offsetWidth/offsetHeight 各种获得宽高的方式 获取屏幕的高度和宽度（屏幕分辨率）：window.screen.height/width 获取屏幕工作区域的高度和宽度（去掉状态栏）window.screen.availHeight/availWidth 网页全文的高度和宽度：document.body.scrollHeight/Width 滚动条卷上去的高度和向右卷的宽度：document.body.scrollTop/scrollLeft 网页可见区域的高度和宽度（不加边线）：document.body.clientHeight/clientWidth 网页可见区域的高度和宽度（加边线）：document.body.offsetHeight/offsetWidth二、居中方式 水平居中内联元素：inline, 内联块inline-block, 内联表inline-table, inline-flex元素及img,span,button等text-align:center;不定宽块元素居中：margin:0 auto;//且需要设置父级宽度通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。 123456789.wrap&#123; float:left; position:relative; left:50%; clear:both;&#125;.wrap-center&#123; left:-50%;&#125; 垂直居中单行内联(inline-)元素垂直居中 通过设置内联元素的高度(height)和行高(line-height)相等，从而使元素垂直居中。 12height: 120px;line-height: 120px; 利用表布局12345678.father &#123; display: table;&#125;.children &#123; display: table-cell; vertical-align: middle; text-align: center; &#125; flex布局12345.center-flex &#123; display: flex; flex-direction: column;//上下排列 justify-content: center;&#125; 绝对布局方式已知高度123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; height: 100px; margin-top: -50px; &#125; 未知高度12345678.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 垂直水平居中flex方式12345.parent &#123; display: flex; justify-content: center; align-items: center;&#125; grid方式1234567.parent &#123; height: 140px; display: grid;&#125;.child &#123; margin: auto;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客部署秘籍]]></title>
    <url>%2F2018%2F10%2F12%2Fcjnbrv3rj0005ha6poghcxvuv%2F</url>
    <content type="text"><![CDATA[摘要Hexo 是用 Node.js 开发的一个静态站点生成器（Static Site Generator），支持 Markdown 语法写作，有着强大的插件系统，而且性能优异。本文将记录如何将hexo在本地搭建的博客部署到阿里云的Ubuntu16.04服务器上。（通过云服务器上的私有 Git 仓库部署到 Web 服务器目录下） 服务端配置在云服务器上安装 Git 和 Nginx 两个必备的软件包。Git 用于版本管理和部署，Nginx 用于静态博客托管。12sudo apt-get updatesudo apt-get install git nginx Git 配置在 /var/repo/ 下，创建一个名为 hexo_static 的裸仓库（bare repo）。如果没有 /var/repo 目录，需要先创建；然后修改目录的所有权和用户权限，之后 ubuntu 用户都具备/var/repo 目录下所有新生成的目录和文件的权限。123sudo mkdir /var/repo/sudo chown -R $USER:$USER /var/repo/sudo chmod -R 755 /var/repo/ 初始化git仓库12cd /var/repo/git init --bare hexo_static.git 配置 Nginx 托管文件目录接下来，创建 /var/www/hexo 目录，用于 Nginx 托管，并修改权限。123sudo mkdir -p /var/www/hexosudo chown -R $USER:$USER /var/www/hexosudo chmod -R 755 /var/www/hexo 修改 Nginx 的 default 设置：1sudo vim /etc/nginx/sites-available/default 将其中的 root 指令指向 /var/www/hexo 目录123456789... server &#123; listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /var/www/hexo; # 需要修改的部分 index index.html index.htm;... 保存并退出文件。如果以后购买并备案域名之后，可以再将配置中的 default_server 修改为你的域名。最后，重启 Nginx 服务，使得改动生效。 创建Git钩子接下来，在服务器上的裸仓库 hexo_static 创建一个钩子，在满足特定条件时将静态 HTML 文件传送到 Web 服务器的目录下，即 /var/www/hexo。在自动生成的 hooks 目录下创建一个新的钩子文件：1vim /var/repo/hexo_static.git/hooks/post-receive 在该文件中添加两行代码，指定 Git 的工作树（源代码）和 Git 目录（配置文件等）。12#!/bin/bashgit --work-tree=/var/www/hexo --git-dir=/var/repo/hexo_static.git checkout -f 保存并退出文件，并让该文件变为可执行文件。1chmod +x /var/repo/hexo_static.git/hooks/post-receive 当当当！！！到这里服务器的配置就完成啦！ 下面来配置_config.yml中的deploy选项 deploy配置首先修改URL为自己的域名或者公网ip地址，比如我的就是www.jinminrui.cn然后修改deploy1234deploy: type: git repo: root@47.100.221.250（云服务器的IP地址）:/var/repo/hexo_static branch: master 最后！一键部署到位！hexo generate &amp;&amp; hexo deploy]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记]]></title>
    <url>%2F2018%2F10%2F12%2Fcjnbrv3re0002ha6p867ix9m0%2F</url>
    <content type="text"><![CDATA[#git#subversion——集中型版本管理系统git——分散型版本管理系统 Git 基本命令1、git init —— 初始化仓库2、git status —— 查看仓库状态3、git add —— 向暂存区中添加文件4、git commit —— 保存仓库的历史记录5、git log——查看提交日志6、git diff——查看更改前后的差别7、git checkout -b [name] —— 以当前master分支创建新的分支 Pull RequestPull Request 是自己修改源代码后，请求对方仓库采纳该修改时采取的一种行为。]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-Router基础]]></title>
    <url>%2F2018%2F10%2F12%2Fcjnbrv3rl0007ha6pthh5cdeo%2F</url>
    <content type="text"><![CDATA[Vue-Router路由中有三个基本的概念 route, routes, router。 1、 route，它是一条路由，由这个英文单词也可以看出来，它是单数， Home按钮 =&gt; home内容， 这是一条route, about按钮 =&gt; about 内容， 这是另一条路由。 2、 routes 是一组路由，把上面的每一条路由组合起来，形成一个数组。[{home 按钮 =&gt;home内容 }， { about按钮 =&gt; about 内容}] 3、router 是一个机制，相当于一个管理者，它来管理路由。因为routes 只是定义了一组路由，它放在哪里是静止的，当真正来了请求，怎么办？ 就是当用户点击home 按钮的时候，怎么办？这时router 就起作用了，它到routes 中去查找，去找到对应的 home 内容，所以页面中就显示了 home 内容。 4、客户端中的路由，实际上就是dom 元素的显示和隐藏。当页面中显示home 内容的时候，about 中的内容全部隐藏，反之也是一样。客户端路由有两种实现方式：基于hash 和基于html5 history api. vue-router中，首先在routes数组中定义所需要的route。 然后创建router 对路由进行管理，它是由构造函数 new vueRouter() 创建，接受routes 参数 最后将router 实例注入到 vue 根实例中,就可以使用路由了 执行过程：当用户点击 router-link 标签时，会去寻找它的 to 属性， 它的 to 属性和 js 中配置的路径{ path: ‘/home’, component: Home} path 一一对应，从而找到了匹配的组件， 最后把组件渲染到 标签所在的地方。所有的这些实现才是基于hash 实现的。 编程式导航：这主要应用到按钮点击上。当点击按钮的时候，跳转另一个组件, 这只能用代码，调用rourter.push() 方法。 当们把router 注入到根实例中后，组件中通过 this.$router 可以获取到router, 所以在组件中使用this.$router.push(&quot;home”)就可以跳转到home界面]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Vue生命周期]]></title>
    <url>%2F2018%2F10%2F12%2Fcjnbrv3rn0008ha6pxmgw3g5s%2F</url>
    <content type="text"><![CDATA[vue提供了如下的钩子函数供我们在vue生命周期的不同时刻调用： beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed 1、在beforeCreate和created钩子函数之间的生命周期在这个生命周期之间，进行初始化事件，进行数据的观测，可以看到在created的时候数据已经和data属性进行绑定（放在data中的属性当值发生改变的同时，视图也会改变）。~注意看下：此时还是没有el选项~ 2、created钩子函数和beforeMount间的生命周期 首先会判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。template参数对生命周期的影响：（1）如果vue实例对象中有template参数选项，则将其作为模板编译成render函数。（2）如果没有template选项，则将外部HTML作为模板编译。（3）可以看到template中的模板优先级要高于outer HTML的优先级。在vue对象中还有一个render函数，它是以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX.123456new Vue(&#123; el: &apos;#app&apos;, render: function(createElement) &#123; return createElement(&apos;h1&apos;, &apos;this is createElement&apos;) &#125;&#125;) 综合排名优先级：render函数选项 &gt; template选项 &gt; outer HTML. 3、beforeMount和mounted 钩子函数间的生命周期此时是给vue实例对象添加$el成员，并且替换掉挂在的DOM元素。 4、mounted在mounted之前h1中还是通过进行占位的，因为此时还有挂在到页面上，还是JavaScript中的虚拟DOM形式存在的。在mounted之后可以看到h1中的内容发生了变化。 5、beforeUpdate钩子函数和updated钩子函数间的生命周期当vue发现data中的数据发生了改变，会触发对应组件的重新渲染，先后调用beforeUpdate和updated钩子函数。在beforeUpdate,可以监听到data的变化但是view层没有被重新渲染，view层的数据没有变化。等到updated的时候 view层才被重新渲染，数据更新。]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
</search>
