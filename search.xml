<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算机组成原理——存储器及存储系统]]></title>
    <url>%2Fhexo%2F2019%2F01%2F04%2Fcjqi4vakz000v5x6pn959r81f%2F</url>
    <content type="text"><![CDATA[计算机组成原理——存储器及存储系统#计算机组成原理 存储器的分类 按存储介质分半导体存储器：如 ram、rom，用作主存磁表面存储器：如磁盘、磁带，用作辅存激光存储器：光盘，用作辅存 按存储方式分随机存储器（RAM）：任何存储单元的内容都能被随机存取，且存取时间和存储单元的物理位置无关串行访问存储器（SAS）：存储单元的内容只能按某种顺序来存取，存取时间与存储单元的物理位置有关，取决于访问存储单元的地址顺序只读存储器（ROM）：对内容只能读不能写入的存储器。 按信息的可保存性分非永久性记忆的存储器：断电后信息即消失的存储器（RAM）永久性记忆的存储器：永久记忆性存储器（ROM） 按在计算机系统中的作用分主存储器、辅助存储器、高速缓存存储器、控制存储器 存储器的性能指标 ： 速度 价格 容量 存储器的分级结构如图所示辅存、主存和缓存的三级存储系统结构，一般来说，“Cache－主存”层次用来弥补主存速度的不足；“主存－辅存”层次用来弥补主存容量的不足。 主存储器主存储器的性能指标 存储容量：在一个存储器中可以容纳的出存储器的单元总数通常称为该存储器的存储容量（单位：字节 B） 存取时间：存储器接受到命令到存储器读（写）出信息的时间 存取周期：连续访问操作过程一次完整存取操作的时间。 存储器带宽：单位时间内存储器所存取的信息量（位/秒，字节/秒） 半导体存储器芯片SRAM：静态随机存取存储器，是随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。DRAM：动态随机存取存储器，是一种半导体内存，主要的作用原理是利用电容内存储电荷的多寡来代表一个二进制比特（bit）是 1 还是 0（电容上电荷的有无）。由于在现实中电容会有漏电的现象，导致电位差不足而使记忆消失，因此除非电容经常周期性地充电，否则无法确保记忆长存。由于这种需要定时刷新的特性，因此被称为“动态”内存。相对来说，静态内存（SRAM）只要存入数据后，纵使不刷新也不会丢失记忆。SRAM 的存取速度快，但集成度低，功耗较大，一般用来组成高速缓冲存储器。DRAM 具有容易集成，位价低，容量大和功耗低等优点。但是存取速度比 SRAM 慢，一般用来组成大容量的主存系统。 动态 MOS 存储器 DRAM 的刷新 采用读出的方式进行刷新，按行来刷新，（行：单个芯片的单个矩阵的行数） 刷新有三种方式：集中式、分散式、异步式半导体只读存储器 MROM(掩模型)：掩模工艺制作, 只能读出, 不能写，可靠性高, 集成度高, 不能重写 PROM: 可一次编程之盾存储器 EPROM: 可擦去可变成只读存储器(用紫外光擦去并且可以重复编程) EEPROM: 电擦去可重写只读存储器 Flash Memoey(闪存存储器)新型的电擦去可编程 ROM, 在 EPROM 功能基础上增加了芯片的点擦除和重新编程能力强特点: 高密度, 可直接执行, 具有 RAM 的读写功能 存储器与 CPU 的连接（见书本和笔记） 位扩展 字扩展 高速缓冲存储器Cache 的功能与基本原理 Cache 是指位于 CPU 和主存之间的一个高速小容量的存储器，一般由 SRAM 构成。 Cache 功能：用于弥补 CPU 和主存之间的速度差异，提高 CPU 访问主存的平均速度。 设置 Cache 的理论基础，是程序访问的局部性原理。 Cache 的内容是主存部分内容的副本，Cache 的功能均由硬件实现，对程序员是透明的。基本原理 CPU 与 Cache 之间的数据交换是以字为单位，而 Cache 与主存之间的数据交换是以块为单位。一个块由若干定长字组成的。 当 CPU 读取主存中一个字时，便发出此字的内存地址到 Cache 和主存。 此时 Cache 控制逻辑依据地址判断此字当前是否在 Cache 中：若在(称为 ~命中~ ），此字立即传送给 CPU；若不在(称为 ~不命中~ ），则用主存读周期把此字从主存读出送到 CPU，与此同时，把含有这个字的整个数据块从主存读出送到 Cache 中。由始终管理 Cache 使用情况的硬件逻辑电路来实现 LRU 替换算法。 主存与 Cache 的地址映射三种方式：直接方式、全相联、组相联 直接映射方式若主存的第 j 块一定映射到 Cache 的第 i 行，Cache 的行号 i 和主存的块号 j 有如下函数关系：i = j mod m（m 是 Cache 中的总行数。优点是硬件简单，成本低。缺点是每个主存块只有一个固定的行位置可存放，容易产生冲突。因此适合大容量 Cache 采用。 全相联映射方式主存中一个块的地址与块的内容一起存于 Cache 的行中，其中块地址存于 Cache 行的标记部分中。这种方法可使主存的一个块直接拷贝到 Cache 中的任意一行上，非常灵活。它的主要缺点是比较器电路难于设计和实现,因此只适合于小容量 Cache 采用。 组相联映射方式这是前两种方式的折衷方案。它把 Cache 存储器分为若干个组，每组包含若干个页面。组间采用直接映像，而组内的页面则采用全相联映像。组相联映射方式中的每组行数 v 一般取值较小，这种规模的 v 路比较器容易设计和实现。而块在组中的排放又有一定的灵活性，冲突减少。 多体交叉存储器 出发点：能够实现同时从存储器取出 n 条指令 特点：通过改进主存的组织方式，在不改变存储器存取周期的情况下，提高存储器的带宽。 结构特点：多体交叉存储器由 M 个的存储体（或称存储模块）组成，每个存储体有相同的容量和存取速度，又有各自独立的地址寄存器、地址译码器、读写电路和驱动电路。 每个模块各自以等同的方式与 CPU 传送信息。CPU 同时访问四个模块，由存储器控制部件控制它们分时使用数据总线进行信息传递。这是一种并行存储器结构。 虚拟存储器基本概念虚拟存储器是建立在主存——辅存物理结构基础之上，由附加硬件装置以及操作系统存储管理软件组成的一种存储体系，它把主存和辅存的地址空间统一编址，形成一个庞大的存储空间。 实地址和虚地址 实地址：实际的主存储器单元的地址，即主存地址，或叫物理地址。 虚地址：虚拟存储器的辅存部分也能让用户象内存一样使用，用户编程时指令地址允许涉及到辅存的空间范围，这种指令地址称为“虚地址”（即虚拟地址），或叫“逻辑地址”。 虚拟存储器的用户程序以虚地址编址并存放在辅存里，程序运行时 CPU 以虚地址访问主存，由辅助硬件找出虚地址和物理地址的对应关系 主存——外存层次和 Cache——主存层次用的地址变换映射方法和替换策略是相同的，都基于程序局部性原理。 虚拟存储器和 Cache 的区别 Cache 存储器采用与 CPU 速度匹配的快速存储元件来弥补主存和 CPU 之间的速度差距；而虚拟存储器的主要功能是弥补了主存和辅存之间的容量差距。 两个存储体系均以信息块作为存储层次之间基本信息的传递单位：Cache 存储器每次传递是定长的的信息块，长度只有几十字节；而虚拟存储器信息块划分方案很多，有页、段等等，长度均在几百 B~几百 KB左右。 CPU 访问快速 Cache 存储器的速度比访问慢速主存快 5~10 倍。虚拟存储器中主存的速度要比辅存快 100~1000 倍以上。 Cache 存储器存取信息的过程、地址变换和替换策略全部用硬件实现。主～辅层次的虚拟存储器基本上由操作系统的存储管理软件辅助一些硬件进行信息块的划分和主～辅存之间的调度。 主存～ Cache 存储体系中 CPU 与 Cache 和主存都建立了直接访问的通路，一旦在主存命中，CPU 将直接访问主存；辅助存储器与 CPU 之间没有直接通路，一旦在主存不命中，只能从辅存调度信息块到主存。同时因为辅存的速度相对 CPU 差距太大，调度需要毫秒级时间，因此 CPU 一般将改换执行另一个程序，等到调度完成后再返回原程序继续工作。 页式虚拟存储器 页是主存物理空间中划分出来的等长的固定区域。 页式虚拟存储系统中，虚拟空间分成页，称为逻辑页；主存空间也分成同样大小的页，称为物理页。 虚存地址分为两个字段：逻辑页号 页内行地址 实存地址也分两个字段：物理页号 页内行地址 ~虚拟存储器地址~到~主存地址~的变换是由放在主存的页表实现的。 页表中每一个虚存逻辑页号有一个表目，表目内容包含该逻辑页所在的主存页面地址(物理页号)，用它作为实存地址的高字段，与虚存地址的页内行地址字段相拼接，产生完整的实主存地址，据此来访问主存。 为了避免页表已保存或已调入主存储器时对主存访问次数的增多，把页表的最活跃部分存放在高速存储器中组成快表。 快表由硬件组成，比页表小得多，只是慢表的小副本。查表时，由逻辑页号同时去查快表和慢表，当在快表中有此逻辑页号时，就能很快地找到对应的物理页号送入实主存地址寄存器。 优点是页面的起点和终点地址是固定的,方便造页表,新页调入主存也很容易掌握，比段式空间浪费小。 缺点是处理、保护和共享都不及段式来得方便。 段式虚拟存储器 段是按照程序的逻辑结构划分成的多个相对独立部分，作为独立的逻辑单位，各个段的长度因程序而异。 虚拟地址由段号和段内地址组成，为了把虚拟地址变换成实主存地址，需要一个段表。 优点是段的逻辑独立性使它易于编译、管理、修改和保护，也便于多道程序共享；某些类型的段具有动态可变长度,允许自由调度以便有效利用主存空间。 缺点是因为段的长度各不相同，起点和终点不定，给主存空间分配带来麻烦，而且容易在段间留下许多空余的零碎存储空间，造成浪费。 段页式虚拟存储器 段页式虚拟存储器是段式虚拟存储器和页式虚拟存储器的结合。 它把程序按逻辑单位分段以后，再把每段分成固定大小的页。 程序对主存的调入调出是按页面进行的，但它又可以按段实现共享和保护，兼备页式和段式的优点。 缺点是在映象过程中需要多次查表。 存储校验技术检错码 奇偶校验包含奇校验和偶校验两种校验。 奇校验约定的编码规律，是让整个校验码（包含有效信息和校验位）中“1”的个数为奇数。 偶校验约定的编码规律，是让整个校验码中“1”的个数为偶数。 这个校验位取“0” 还是取“1”的原则是：若是奇校验，则连同校验位在内编码里含“1”的个数共有奇数个；若是偶校验，则连同校验位在内编码里含“1”的个数是偶数个。 纠错码 常用的纠错码有海明码、循环码等。 只要使用足够的校验位，就可以达到对任何错误的检测和纠错水平。 若需要校正字长 k位的单错，则必须添加 r个校验位，它能够指出k+r个错误及无错误的情况，r必须满足 2 的 r 次方 ≥k+r+1。]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理——运算方法与运算器]]></title>
    <url>%2Fhexo%2F2019%2F01%2F04%2Fcjqi4vakd000g5x6plkcqmlre%2F</url>
    <content type="text"><![CDATA[数值数据的表示 计算机中的数据表示，包括定点数、浮点数、字符、十进制数的表示方法 ; 原码、补码、反码、移码等码制之间的关系以及各码制之间真值数的转换； 原码求补码的方法：正数，不变，即原码=补码负数，符号位不变，数值为取反并加 1 补码中零只有一个：0.0000000 补码 1.0000000 表示负 1 原码 如果机器字长为 n，那么一个数的原码就是用一个 n 位的二进制数，其中最高位为符号位：正数为 0，负数为 1。剩下的 n-1 位表示该数的绝对值 正数的原、反、补码都一样，0 的原码跟反码都有两个，因为这里 0 被分为+0 和-0。 反码 反码就是在原码的基础上，符号位不变其他位按位取反(就是 0 变 1，1 变 0)就可以了 补码 补码也非常的简单，就是在反码的基础上按照正常的加法运算加 1 负数的补码这么记更简单： ~符号位不变，其他的从低位开始，直到遇见第一个 1 之前，什么都不变；遇见第一个 1 后保留这个 1，以后按位取反~ 除此之外，还可以用 [1000_0000]补 表示-128：(-1) + (-127) = [1000_0001]原 + [1111_1111]原 = [1111_1111]补 + [1000_0001]补 = [1000_0000]补-1-127 的结果应该是-128，在用补码运算的结果中， [1000_0000]补 就代表-128。注意，-128 并没有原码和反码表示。 移码 移码最简单了，不管正负数，只要将其补码的符号位取反即可。 数的浮点表示法阶码决定范围，尾数决定精度。 浮点数的规格化为了使浮点表示法有尽可能高的精度，采取的措施之一是增加位数，或者在字长一定的情况下将阶码和尾数所占的位数协调好，措施之二是采用浮点数规格化表示，就是通过调整界面，使其尾数满足以下形式：原码规格化后： 正数为 0.1×……× 的形式，负数为 1.1×……× 的形式。补码规格化后 ： 正数为 0.1×……× 的形式，负数为 1.0×……× 的形式。 非数值数据的表示 ASCII 码有 7 位，总共 128 个，最高位区分是否是汉字 区位码（十六进制）+ 2020H = 国标码 机内码 = 国标码 + 8080H 一个汉字占 2 个字节 16 位机内码。 定点加减法运算溢出判断 双符号位法 进位判断法]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理——概述]]></title>
    <url>%2Fhexo%2F2019%2F01%2F04%2Fcjqi4vak7000c5x6pk5ib6xr5%2F</url>
    <content type="text"><![CDATA[计算机的发展 第五代的计算机是通信、存储、信息处理和人工智能相结合的超巨型计算机。 第六代计算机，作为计算机的核心元件不是传统的电子元件。而是更新的光电子元件、超导电子元件或生物电子元件。 人工智能（artificial intelligence）是计算机模拟人类的智能活动，包括感知、判断、理解、学习、问题求解和图像识别等。 大数据的四大特征：海量的数据规模（volume）、多样的数据类型（variety）、价值密度低（value）、快速的数据处理（velocity）。- 计算机系统的组成一台完整的计算机应包括硬件部分和软件部分 计算机的硬件系统 冯·诺伊曼计算机体系结构：存储器：存放数据和程序（按地址顺序存储）运算器：算术运算和逻辑运算控制器：指挥程序运行，内含程序计数器输入设备：将信息转换成机器能识别的形式输出设备：将结果转换成人们熟悉的形式 冯·诺伊曼思想：硬件系统、二进制、自动顺序执行、指令、程序 存储程序原理：程序设计者事先按一定要求编好程序，把它和数据一起存入存储器内，而机器能自动地按照程序执行一条条指令，这样就可以使全部运算成为真正的自动过程。 运算器和控制器合称 CPU。CPU 和存储器通常组装在一个主板上，合称主机。 计算机中有两股信息在流动：一股是控制信息，其发源地是控制器，它分散流向各个部件；另一股是数据信息，它受控制信息的控制，从一个部件流向另一个部件，边流动边被加工处理。 计算机的软件系统 软件按其功能分为应用软件和系统软件两大类。合称支撑软件。 计算机系统的层次结构。 微程序设计级：是一个实在的硬件级，它由机器硬件直接执行微指令 一般机器级：由微程序解释机器指令系统。硬件级 操作系统级：有操作系统程序实现。混合级 汇编语言级：提供一种符号形式的语言 高级语言级：面向用户，为方便用户编写程序而设置 一条机器语言对应一段微程序 计算机的特点、性能指标及分类计算机的工作特点 快速性 通用性 准确性 逻辑性 计算机的性能指标 基本字长指参与运算的数的基本长度，用二进制位的长短来衡量 主存容量 运算速度用每秒能执行的指令条数来表示，单位是条/秒MFLOPS 每秒执行百万条浮点指令条数 CPU 处理时间]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unix/Linux系统基础]]></title>
    <url>%2Fhexo%2F2018%2F12%2F25%2Fcjqi4vaky000u5x6pm2g697lr%2F</url>
    <content type="text"><![CDATA[一、Unix 操作系统基础1、shellshell 是内核与用户之间的接口，是一个交互的命令解释器 2、unix 目录组织 在 unix 中，一切都是文件，文件组织成目录，目录是一种组织和控制文件访问的很好的方式，用户可以为目录设置权限以允许其他人访问的文件或只允许自己访问 文件类型：1、普通文件2、目录文件3、字符设备文件4、块设备文件 二、Unix 基本命令\$提示符是 bourne shell、korn shell、posix shell 的标准提示符%提示符通常是 c shell 的提示符“#”提示符一般是为系统管理员保留的用分号分割一行中两个命令 1、几种命令 man命令用来查看帮助手册man 4 passwd用来查看 passwd 的手册的第四节的内容 who命令报告有哪些用户已经登陆系统，每一个用户连接的终端和登陆时间的信息。who am i报告本用户的用户名和端口信息。whoami命令报告系统与本地终端关联的用户吗 write命令向当前登陆到同一个系统的用户的终端发送信息并显示，实现了通过终端的交互对话。 echo命令用于向屏幕上打印信息~双引号~ ：可引用除了字符\$、`、\外的任意字符或字符串~单引号~ ：shell 会忽略任何引用值，即屏蔽单引号内的特殊字符的原本含义。~反引号~ ：shell 认为反引号中的内容是一个系统命令 date命令可以用来显示或设定系统的日期与时间，在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记 12date +%Y%m%d20184012/23/18 passwd命令为你的账户设置密码 uname查看当前系统的版本号 2、命令语法 通配符“?”表示任意单个字符“*”表示任何字符“[]”表示括号中的任意一个字符 重定向字符标准输入： &lt;标准输出： &gt; &gt;&gt;在原来文件内容的基础上附加标准错误输出：2&gt; 命令行选项用一个破折线定义命令的不同形式 管道符“|” 完成两程序的连接，例如ps -ef | more常用于过滤、修改或维护命令的输出 后台处理将任务放在后台处理，例如 “&amp;” 3、文件系统目录文件通常是数据的容器，而目录是文件或者其他目录的容器。 /opt 这个目录会用来存放应用程序和产品 /usr/bin 包含的基础的 unix 系统操作和文件处理的命令 /usr/lib 包含应用程序使用的文档和共享的库 /usr/local/bin 存放本地开发的程序的工具（/usr/contrib/bin 存放公用的） /etc 系统配置文件 /stand/vmunix 存放系统内核文件 /tmp 通常作为操作系统的一个临时空间 /dev 存放可以被连接到系统硬件设备的文件，通常被叫做“设备文件” 4、文件权限drwxr-xr-x第一位 l 软连接 d 目录 b 块文件 c 字符 -都不是 ；后 9 位每三位分别是 user、group、other 的权限：read、write、execute 5、文件系统命令 pwd 查看当前目录 ls 查看目录下文件名（ll 会显示详细信息）-a 显示所有文件-d 列出文件描述-l 每一个文件描述属性的长列表-F 在每个目录后面加反斜杠/，在可执行文件后面加星号*-R 递归地列出给出的目录和所有子目录中的文件 cd 进入目录 find 找到文件 mkdir 创建目录 rmdir 删除目录 more 一次一屏的显示 cp 复制文件 cp file1 fiel2-i 会在复制时向你确认是否覆盖旧文件-r 选项可复制目录-p 复制时保留权限 mv 移动或者给文件重命名 touch 创建新文件touch 命令有以下选项：-a time 更改存取(Access)时间为指定的时间-m time 更改修改(Modify)时间为指定的时间-t time 使用指定时间(time)来代替当前时间。-c 如果文件不存在，不创建新文件。 find 路径 -name 文件名 cat 命令主要有三大功能： 1.一次显示整个文件。$ cat filename 2.从键盘创建一个文件。$ cat &gt; filename只能创建新文件,不能编辑已有文件. 3.将几个文件合并为一个文件。$cat file1 file2 &gt; file file 命令 查看文件类型 grep 搜索文件内容 统计文本 wc统计行数、字数、字符数wc -[l,w,c] filename whereis 查找命令-b 仅搜索二进制文件-m 仅搜索帮助文件-s 仅搜索源代码 6、用户和用户组管理有关用户账号的文件： passwd 文件：每一个合法用户的账号对应该文件中的一行记录（登陆名：密码：用户标志号：组标志号：用户的全名或其他描述：主目录：登陆 shell） shadow 文件： /etc/shadow 文件存放用户账户的加密密码信息和密码的有效期。 group 文件：/etc/group 存放系统中的所有组（组名：密码：组标志号：用户列表） 使用 useradd 和 groupadd 命令来添加用户和组；修改组属性：groupmod [-g &lt;新 GID&gt; [-o]][-n &lt;新组名&gt;] &lt;现有组名&gt; 三、管理文件1、lp 命令 lp 命令让用户将文件送往打印队列来打印文件。每个使用 lp 提交的打印请求都会被分配一个唯一的任务标识号（称为一个请求 ID）。lp 命令的语法是：lp [-d dest][-n number] [-o option] –t title [-w][file….]一些 lp 命令的选项：-n number 文件打印的重复的份数（默认是 1）。-d dest 打印请求会被送到的打印机的名字。-t title 在打印输出的标题页中打印标题。-o option 指定你的打印机的具体的选项，例如字体，间距，灰度等等-w 在文件打印完成以后，写一条信息到用户的终端。lpstat 报告已经送往打印机队列的打印请求 2、cancel 命令cancel id [id …] 取消一个有 lp 命令产生的打印机任务cannel printer [ printer…] 取消当前在指定打印机上的打印任务 3、ln 命令ln file1 file2 硬链接文件和原文件指向同样的数据，就像克隆一样，inode 号也相同，当删除原文件时，硬链接文件仍然存在有效。但硬链接文件不同于文件的复制，并没有复制原文件数据。简单说，硬链接就是一个类似于别名的概念。当原来的名字没有了，别名照样可以使用。硬链接指通过索引节点来进行的连接硬链接不可以跨文件系统，不能为目录建硬链接看不出硬链接和文件的区别，属性上都用-表示 软链接和 windows 系统的快捷方式含义一样。软链接和原文件的 inode 不同，该文件的内容是指向原文件的路径信息。软链接就好像是指针一样。而硬链接就是引用。软链接可以跨文件系统属性上用 l 表示 4、文件的权限管理 chmod 改变文件的存取权限 chown 改变一个文件的属主，只有文件的属主和 root 才能更改一个文件的所有权 umask 改变默认的文件存取权限 chgrp 改变一个文件的组 su 转换你的用户的身份 newgrp 转换你的组的身份 四、定制工作环境 alias 为命令设置别名alias dir=&#39;ls&#39; tab 文件名自动补全 history 历史命令，在默认方式下，bash 使用用户主目录下面的文件“.bash_history”来保存历史命令改变存放历史命令的文件# HISTFILE=“/home/mengqc/.myhistory”重新设定能够保留的命令个数# HISTSIZE=600 1、环境变量 使用env命令来查看用户环境变量注意，多数环境变量，都需要export才起作用例如 # export $PATH 与环境变量相关的全局配置文件/etc/bashrc 全局配置/etc/profile 登录 shell 的全局配置 个人配置文件，每个登录用户的 home 目录下有：~/.bshrc~/.bash_profile~/.cshrc 五、vi 编辑器1、开始指令 vi +n filename 进入 vi 并且由文件的第几行开始。 vi +filename 进入 vi 并且由文件的最后一行开始。 vi + /word filename 进入 vi 并且由文件的 word 这个字开始。 vi filename(s) 进入 vi 并且将各指定文件列入名单内，第一个文件先读入。（多文件） vedit 进入 vi 并且在输入方式时会在状态行显示“INSERT MODE”。 2、加数据指令 i 在关标位置开始插入字符，结束时候按 ESC 键。 I 在光标所在行首开始加字，结束时按 ESC 键。 a 在光标位置后开始加字，结束时按 ESC 键。 A 在光标所在行尾部开始加字，结束时按 ESC 键。 o 在光标所在行下插入一空白行并开始加字。 O 在光标所在行上插入一空白行并开始加字。 3、删除指令 x 删除光标处字符。 dw 删除从光标位置开始到单词结束处的字符。 dd 删除当前一整行。 d0 删除从行首到光标位置的字符。 d\$ 或 D 删除从光标位置到行尾的字符。 nx 删除由光标位置起始的 n 个字符（含光标位置） nX 删除由光标位置起始的 n 个字符（不含光标位置）。 ndw 删除光标位置开始的 n 个字符组（word)。 ndd 将光标位置起始的 n 行（整行）删除。 :start,endd 删除文件的第 start 到 end 行。 4、光标移动h 往左移 1 位l 或者 spacebar 往右移 1 位k 向上移 1 行j 向下移 1 行0 移到一行的开始\$ 移到一行的末尾[ 移到文件开始位置] 移到文件结束位置G 移到文件的最后一行nG 或者:n 移到文件的第 n 行Ctrl + u 屏幕上卷半屏Ctrl + d 屏幕下卷半屏Ctrl + b 屏幕上卷一屏Ctrl + f 屏幕下卷一屏 5、查找与替换r 修改光标所指的字符R 从光标位置开始修改，结束时按 ESC 键/text 从光标位置往下找字串 text?text 从光标位置往上找字串 textn 继续找下一个字串（在输入上面的查找指令之后使用）[range]s/old_string/new_string[ /option ] 将指定范围内的字符处替换为新串 6、复制及移动文本nY 复制光标所在位置开始的 n 行数据p 将数据粘贴在光标的下一行P 将数据粘贴在光标的上一行:first,last co dest 将 first 到 last 行的数据复制到目标行(dest）下面:Start,end m dest 将 start 到 end 行的数据移动到目标行（dest)下。 :r filename 将指定文件的内容读入光标所在行下。 六、shell 编程基础1、示例12345678#！ /bin/bash# create a group of filesfor((i=1;i&lt;=10;i++))do touch tt$i echo this is tt$i &gt;&gt; tt$idonels -l tt* 2、执行 shell 脚本的基本方法 source test.sh sh test.sh 12* chmod 755 test.sh ./test.sh 3、变量 定义变量变量名=字符串 【注意，等号左右无空格】 如果变量值须出现在长字符串的开头或者中间，为了使变量名与其后的字符区分开，避免 shell 把它与其它字符混在一起视为一个新变量，则应该用花括号将该变量名括起来。 命令替换除了反引号的另一种形势： $(pwd) 声明一个数组：declare -a 数组名定义数组： a=(1 2 3 4 .... n)其中，各个值之间以空格分开。读取数组元素值：echo ${数组名[下标]} 若没有给出数组元素的下标，则数组名表示下标为 0 的数组元素 逻辑操作符 &amp;&amp; ||cmd1 &amp;&amp; cmd2 仅当命令 cmd1 执行成功时，才会执行命令 cmd2。cmd1 || cmd2 仅当命令 cmd1 执行失败时，才会执行命令 cmd2。 位置参数 0,1,2,……命令行实参与脚本中位置变量的对应关系如下所示：exam1 m1 m2 m3 m4$0 $1 $2 $3 $4 $5 $6 $7 $8 $9 ${10} ${11}引用它们的方式依次是$0, $1, $2, …, $9, ${10}, ${11}等。其中，\$0 始终表示命令名或 shell 脚本名。使用 set 命令为位置参数赋值 特殊变量$# 表示命令行上实际参数的个数(不包括shell程序名本身)$ 表示命令行实际给出的所有实参字符串\$@ 表示命令行实际给出的所有实参字符串 注意:\$和$@基本功能相同，但是当两侧有双引号时则存在差别!即:① “$*”把实际给出的所有实参当作一个整体，即一个字符串。② “\$@”把实际给出的每个实参当作一个字符串，即多个字符串。 4、算术运算12345678910111213a=4;b=3((c=a+b))echo $c--------------a=4;b=3let &quot;c=b-a&quot;echo $c--------------expr 4 + 37a=`expr 4 + 3`echo $a7 在算术表达式中，变量名可以直接使用，不需要加\$使用 expr 命令进行算术运算，运算符两侧必须有空格-f 是否是文件-d 是否是目录 5、函数 示例 12345678910111213ave()&#123; sum=0; for((i=0;i&lt;=n;i++)) do ((sum=sum+a[i])) done ((sum=sum/n)) echo $sun&#125;n=5a=(90 82 84 72 61)ave 七、系统管理1、前、后台执行 命令行末尾，加 &amp; 字符，作业放到后台执行 组合键【ctrl -z】：把正在前台执行的作业挂起，并置于后台 fg 命令：fg &lt;作业号&gt;把后台作业调到前台执行 bg 命令：bg &lt;作业号&gt;让后台挂起的作业继续在后台执行 jobs 命令： 了解当前作业情况 nohup 命令 用户退出后作业继续执行 2、查看进程ps 命令查看进程，常用格式： ps -ef ps aux ps -ef | grepgrep: -n, -v, -iand -c.-c显示每个文件中匹配的行数-i不分大小写-n显示匹配行的行号-v显示不匹配的行（匹配的行不显示）例如 ps –ef|grep -i python|grep –v grep 3、有过滤作用的命令 head –n 20 /etc/passwd tail –n 20 /etc/passwd tail –f /log/xxx.log 查看正在改变的日志 more less wc 统计行、字、字符等 既显示结果，又存入文件，用 tee 实现 ls /home | tee dir.list- 4、备份与压缩 tar-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 -z：有 gzip 属性的-j：有 bz2 属性的-Z：有 compress 属性的-v：显示所有过程-O：将文件解开到标准输出 下面的参数-f 是必须的 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 gzip gunzip unzip 5、网络命令 ping 命令ping[选项] 目的地 ifconfig 用来配置一个网络接口 123456789* 示例：## 显示所有当前活动的网络接口的情况。ifconfig## 显示指定网络接口eth0的情况。ifconfig eth0## 配置一个以太网接口，以给定IP地址定义这个网络接口的地址。同时，ifconfig命令自动地创建一个标准的广播地址和子网掩码。ifconfig eth0 211.68.38.133## 指定以太网卡eth0的IP地址为211.68.38.133，广播地址为211.68.38.255,子网掩码为255.255.255.0。ifconfig eth0 211.68.38.133 broadcast 211.68.38.255 netmask 255.255.255.0 netstat 命令 统计 TCP/IP 网络协议的连接。netstat 显示当前已经创建的连接netstat -nr 将显示路由表 route 命令route 命令为数据传递所需的网络连接配置路由信息。]]></content>
      <tags>
        <tag>Unix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊JavaWeb项目后端和前端的交互]]></title>
    <url>%2Fhexo%2F2018%2F11%2F27%2Fcjqi4vakc000e5x6pf9iiqk1n%2F</url>
    <content type="text"><![CDATA[最近在做学校老师的一个钢管租赁网站的项目，我负责前端的开发。再加上期中考试和各种各样的作业博客也是好久没有更新了（=·=好吧其实是我懒）言归正传，这也算是我第一次参加正式的开发项目，前前后后改了不少次，但确实是学到了很多东西，这和自己平时在网上看看博客写写demo完全是不一样的。这个项目的后台是很早就已经开发得差不多了的。项目采取前后端代码分离的架构，即前端是完全的html格式文件，并非jsp模版文件，数据渲染一律采用ajax方式请求后端获取。今天就来聊一聊JavaWeb项目后端和前端的交互问题，一是增强记忆，二来最近身边的同学也在学习JavaWeb的开发（好像都很懵逼的样子，其实我也只了解一些皮毛） 后端Controller的编写现在jave web后端的主流框架为SSM（Spring SpringMVC Mybatis）或者是SpringBoot + Mybatis。它们都是以MVC为基础的框架，在前后端代码分离的项目中，编写Controller层简单粗暴的说就是设计接口以便前端调用。下面是一段SpringBoot中Controller层的代码：1234567891011121314@Controller@RequestMapping(&quot;/api&quot;)public class DemoController &#123; @RequestMapping(value=“/getinfo”,method=RequestMethod.GET) @ResponseBody private Map&lt;String,Object&gt; getInfo()&#123; Map&lt;String,Object&gt; modelMap = new HashMap&lt;String,Object&gt;(); ... ... ... (调用service层的接口） return modelMap; &#125;&#125; 这就是一个可以通过get方式请求的接口，运行项目，访问http://localhost:8080/projectname/api/getinfo 便可以获取json格式的数据。如果是post方式的请求，那么将代码@RequestMapping(value=“/getinfo”,method=RequestMethod.GET)中的GET改为POST，并使getInfo方法接收一个参数HttpServletRequest request ，然后在方法内处理请求体获取需要的数据便可（具体处理在这里不详述） 前端ajax调用接口这里便不仔细解释了，给出get与post两种方式的ajax请求模版（使用jquery）具体的参数大家可以自行谷歌了解。GET方式：1234$.getJSON(initUrl, function(data) &#123; ... ... &#125;); POST方式：12345678910111213141516$.ajax(&#123; url : Url, type : ‘POST’, data : formData, contentType : false, processData : false, cache : false, success : function(data) &#123; if (data.success) &#123; $.toast(‘提交成功！’); &#125; else &#123; $.toast(‘提交失败！’ + data.errMsg); console.log(data.errMsg); &#125; &#125;&#125;);]]></content>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当你在地址栏输入了一行网址……]]></title>
    <url>%2Fhexo%2F2018%2F10%2F16%2Fcjqi4vak5000b5x6py2sx0h7k%2F</url>
    <content type="text"><![CDATA[当你在浏览器的地址栏输入了一行网址，并回车了之后，浏览器到底做了什么呢？ 先笼统的讲一下：浏览器通过 DNS 解析你输入的网址（ URL ）根据网址中的域名（Domain）部分也就是www.xxxxx.com获取域名对应的IP地址，然后通过基于 TCP/IP 协议的 http 协议发送请求到服务器，服务器响应请求返回数据，浏览器接收数据解析并 渲染 到页面。 我们总结出几个关键词： DNS解析 URL TCP/IP HTTP协议 HTTP请求发起和响应 页面渲染的过程 DNS解析DNS:Domain Name Server，域名服务器。是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。IP地址其实就是一串乱七八糟的数据用户很难记住，但是域名就不一样了，比如谷歌的google.com，百度的baidu.com 简单易记。所以为了处理这个问题，就需要用域名去映射IP地址。因此，当用户在浏览器输入https://www.baidu.com 回车时，它经历了以下步骤： 1.浏览器根据地址去本身缓存中查找dns解析记录，如果有，则直接返回IP地址，否则浏览器会查找操作系统中（hosts文件）是否有该域名的dns解析记录，如果有则返回。2.如果浏览器缓存和操作系统hosts中均无该域名的dns解析记录，或者已经过期，此时就会向域名服务器发起请求来解析这个域名。3.请求会先到LDNS（本地域名服务器），让它来尝试解析这个域名，如果LDNS也解析不了，则直接到根域名解析器请求解析4.根域名服务器给LDNS返回一个所查询余的主域名服务器（gTLDServer）地址。5.此时LDNS再向上一步返回的gTLD服务器发起解析请求。6.gTLD服务器接收到解析请求后查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是你注册的域名服务器（比如阿里dns、腾讯dns等）7.Name Server域名服务器会查询存储的域名和IP的映射关系表，正常情况下都根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器8.返回该域名对应的IP和TTL值，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间有TTL值控制。9.把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。 URLURL：Uniform Resource Locator 统一资源定位符。说白了就是网络上用来标识具体资源的一个地址，包含了用户查找该资源的信息，HTTP使用它来传输数据和建立连接。一个URL有以下组成部分： 1. 协议 2. 服务器地址（域名或IP+端口） 3. 路径 4. 文件名 TCP/IP协议TCP：Transmission Control Protocol， 传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。双方建立TCP连接需要经历三次握手： 1.客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认。2.服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。3.客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 上面几个状态码的解释： 1.SYN:synchronous 建立联机2.ACK:acknowledgement 确认3.SYN_SENT:请求连接4.SYN_RECV:服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态。再进一步接收到客户端的ACK就进入ESTABLISHED状态。TCP连接时并不携带数据 HTTP协议HTTP协议：Hypertext Transfer Protocol 也叫超文本传送协议 ，它是一种基于TCP/IP协议栈、在表示层和应用层上的协议（TCP在传输层的协议），通俗一点说就是TCP/IP是位于传输层上的一种协议，用于在网络中传输数据；HTTP协议是应用层协议，基于TCP协议，用于包装数据，程序使用它进行通信，可以简单高效的处理通信中数据的传输和识别处理。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局笔记]]></title>
    <url>%2Fhexo%2F2018%2F10%2F16%2Fcjqi4vajz00055x6ptdqbmajs%2F</url>
    <content type="text"><![CDATA[一、盒模型 ie 盒模型算上 border、padding 及自身（不算 margin），标准的只算上自身窗体的大小 css 设置方法如下： 1234/* 标准模型 */box-sizing:content-box; /*IE模型*/box-sizing:border-box; margin、border、padding、content 由外到里 最常用的获得宽高的方式dom.offsetWidth/offsetHeight 各种获得宽高的方式 获取屏幕的高度和宽度（屏幕分辨率）：window.screen.height/width 获取屏幕工作区域的高度和宽度（去掉状态栏）window.screen.availHeight/availWidth 网页全文的高度和宽度：document.body.scrollHeight/Width 滚动条卷上去的高度和向右卷的宽度：document.body.scrollTop/scrollLeft 网页可见区域的高度和宽度（不加边线）：document.body.clientHeight/clientWidth 网页可见区域的高度和宽度（加边线）：document.body.offsetHeight/offsetWidth 二、居中方式 水平居中内联元素：inline, 内联块 inline-block, 内联表 inline-table, inline-flex 元素及 img,span,button 等text-align:center;不定宽块元素居中：margin:0 auto;//且需要设置父级宽度通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。 123456789.wrap&#123; float:left; position:relative; left:50%; clear:both;&#125;.wrap-center&#123; left:-50%;&#125; 垂直居中单行内联(inline-)元素垂直居中 通过设置内联元素的高度(height)和行高(line-height)相等，从而使元素垂直居中。 12height: 120px;line-height: 120px; 利用表布局 12345678.father &#123; display: table;&#125;.children &#123; display: table-cell; vertical-align: middle; text-align: center;&#125; flex 布局 12345.center-flex &#123; display: flex; flex-direction: column;//上下排列 justify-content: center;&#125; 绝对布局方式已知高度 123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; height: 100px; margin-top: -50px;&#125; 未知高度 12345678.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 垂直水平居中flex 方式 12345.parent &#123; display: flex; justify-content: center; align-items: center;&#125; grid 方式 1234567.parent &#123; height: 140px; display: grid;&#125;.child &#123; margin: auto;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客部署秘籍]]></title>
    <url>%2Fhexo%2F2018%2F10%2F12%2Fcjqi4vak300085x6pxpstc328%2F</url>
    <content type="text"><![CDATA[摘要Hexo 是用 Node.js 开发的一个静态站点生成器（Static Site Generator），支持 Markdown 语法写作，有着强大的插件系统，而且性能优异。本文将记录如何将hexo在本地搭建的博客部署到阿里云的Ubuntu16.04服务器上。（通过云服务器上的私有 Git 仓库部署到 Web 服务器目录下） 服务端配置在云服务器上安装 Git 和 Nginx 两个必备的软件包。Git 用于版本管理和部署，Nginx 用于静态博客托管。12sudo apt-get updatesudo apt-get install git nginx Git 配置在 /var/repo/ 下，创建一个名为 hexo_static 的裸仓库（bare repo）。如果没有 /var/repo 目录，需要先创建；然后修改目录的所有权和用户权限，之后 ubuntu 用户都具备/var/repo 目录下所有新生成的目录和文件的权限。123sudo mkdir /var/repo/sudo chown -R $USER:$USER /var/repo/sudo chmod -R 755 /var/repo/ 初始化git仓库12cd /var/repo/git init --bare hexo_static.git 配置 Nginx 托管文件目录接下来，创建 /var/www/hexo 目录，用于 Nginx 托管，并修改权限。123sudo mkdir -p /var/www/hexosudo chown -R $USER:$USER /var/www/hexosudo chmod -R 755 /var/www/hexo 修改 Nginx 的 default 设置：1sudo vim /etc/nginx/sites-available/default 将其中的 root 指令指向 /var/www/hexo 目录123456789... server &#123; listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /var/www/hexo; # 需要修改的部分 index index.html index.htm;... 保存并退出文件。如果以后购买并备案域名之后，可以再将配置中的 default_server 修改为你的域名。最后，重启 Nginx 服务，使得改动生效。 创建Git钩子接下来，在服务器上的裸仓库 hexo_static 创建一个钩子，在满足特定条件时将静态 HTML 文件传送到 Web 服务器的目录下，即 /var/www/hexo。在自动生成的 hooks 目录下创建一个新的钩子文件：1vim /var/repo/hexo_static.git/hooks/post-receive 在该文件中添加两行代码，指定 Git 的工作树（源代码）和 Git 目录（配置文件等）。12#!/bin/bashgit --work-tree=/var/www/hexo --git-dir=/var/repo/hexo_static.git checkout -f 保存并退出文件，并让该文件变为可执行文件。1chmod +x /var/repo/hexo_static.git/hooks/post-receive 当当当！！！到这里服务器的配置就完成啦！ 下面来配置_config.yml中的deploy选项 deploy配置首先修改URL为自己的域名或者公网ip地址，比如我的就是www.jinminrui.cn然后修改deploy1234deploy: type: git repo: root@47.100.221.250（云服务器的IP地址）:/var/repo/hexo_static branch: master 最后！一键部署到位！hexo generate &amp;&amp; hexo deploy]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记]]></title>
    <url>%2Fhexo%2F2018%2F10%2F12%2Fcjqi4vajn00005x6pnbp78bbw%2F</url>
    <content type="text"><![CDATA[#git#subversion——集中型版本管理系统 git——分散型版本管理系统 Git 基本命令1、git init —— 初始化仓库2、git status —— 查看仓库状态3、git add —— 向暂存区中添加文件4、git commit —— 保存仓库的历史记录5、git log——查看提交日志6、git diff——查看更改前后的差别7、git checkout -b [name] —— 以当前 master 分支创建新的分支 Pull RequestPull Request 是自己修改源代码后，请求对方仓库采纳该修改时采取的一种行为。]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-Router基础]]></title>
    <url>%2Fhexo%2F2018%2F10%2F12%2Fcjqi4vaju00025x6ph3tiwhvn%2F</url>
    <content type="text"><![CDATA[Vue-Router路由中有三个基本的概念 route, routes, router。 1、 route，它是一条路由，由这个英文单词也可以看出来，它是单数， Home 按钮 =&gt; home 内容， 这是一条 route, about 按钮 =&gt; about 内容， 这是另一条路由。 2、 routes 是一组路由，把上面的每一条路由组合起来，形成一个数组。[{home 按钮 =&gt;home 内容 }， { about 按钮 =&gt; about 内容}] 3、router 是一个机制，相当于一个管理者，它来管理路由。因为 routes 只是定义了一组路由，它放在哪里是静止的，当真正来了请求，怎么办？ 就是当用户点击 home 按钮的时候，怎么办？这时 router 就起作用了，它到 routes 中去查找，去找到对应的 home 内容，所以页面中就显示了 home 内容。 4、客户端中的路由，实际上就是 dom 元素的显示和隐藏。当页面中显示 home 内容的时候，about 中的内容全部隐藏，反之也是一样。客户端路由有两种实现方式：基于 hash 和基于 html5 history api. vue-router 中，首先在 routes 数组中定义所需要的 route。 然后创建 router 对路由进行管理，它是由构造函数 new vueRouter() 创建，接受 routes 参数 最后将 router 实例注入到 vue 根实例中,就可以使用路由了执行过程：当用户点击 router-link 标签时，会去寻找它的 to 属性， 它的 to 属性和 js 中配置的路径{ path: ‘/home’, component: Home} path 一一对应，从而找到了匹配的组件， 最后把组件渲染到 标签所在的地方。所有的这些实现才是基于 hash 实现的。 编程式导航：这主要应用到按钮点击上。当点击按钮的时候，跳转另一个组件, 这只能用代码，调用`rourter.push()` 方法。 当们把router 注入到根实例中后，组件中通过 this.$router 可以获取到router, 所以在组件中使用 this.$router.push(&quot;home”)就可以跳转到 home 界面]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Vue生命周期]]></title>
    <url>%2Fhexo%2F2018%2F10%2F12%2Fcjqi4vak100075x6pd7ug1aia%2F</url>
    <content type="text"><![CDATA[vue 提供了如下的钩子函数供我们在 vue 生命周期的不同时刻调用： beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed 1、在 beforeCreate 和 created 钩子函数之间的生命周期在这个生命周期之间，进行初始化事件，进行数据的观测，可以看到在 created 的时候数据已经和 data 属性进行绑定（放在 data 中的属性当值发生改变的同时，视图也会改变）。~注意看下：此时还是没有 el 选项~ 2、created 钩子函数和 beforeMount 间的生命周期 首先会判断对象是否有 el 选项。如果有的话就继续向下编译，如果没有 el 选项，则停止编译，也就意味着停止了生命周期，直到在该 vue 实例上调用 vm.\$mount(el)。template 参数对生命周期的影响：（1）如果 vue 实例对象中有 template 参数选项，则将其作为模板编译成 render 函数。（2）如果没有 template 选项，则将外部 HTML 作为模板编译。（3）可以看到 template 中的模板优先级要高于 outer HTML 的优先级。在 vue 对象中还有一个 render 函数，它是以 createElement 作为参数，然后做渲染操作，而且我们可以直接嵌入 JSX. 123456new Vue(&#123; el: &apos;#app&apos;, render: function(createElement) &#123; return createElement(&apos;h1&apos;, &apos;this is createElement&apos;) &#125;&#125;) 综合排名优先级：render 函数选项 &gt; template 选项 &gt; outer HTML. 3、beforeMount 和 mounted 钩子函数间的生命周期此时是给 vue 实例对象添加\$el 成员，并且替换掉挂在的 DOM 元素。 4、mounted在 mounted 之前 h1 中还是通过进行占位的，因为此时还有挂在到页面上，还是 JavaScript 中的虚拟 DOM 形式存在的。在 mounted 之后可以看到 h1 中的内容发生了变化。 5、beforeUpdate 钩子函数和 updated 钩子函数间的生命周期当 vue 发现 data 中的数据发生了改变，会触发对应组件的重新渲染，先后调用 beforeUpdate 和 updated 钩子函数。在 beforeUpdate,可以监听到 data 的变化但是 view 层没有被重新渲染，view 层的数据没有变化。等到 updated 的时候 view 层才被重新渲染，数据更新。]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
</search>
